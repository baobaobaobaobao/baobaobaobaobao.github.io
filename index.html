<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="baobaobao" />










<meta name="description" content="求道者">
<meta property="og:type" content="website">
<meta property="og:title" content="baobaobao">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="baobaobao">
<meta property="og:description" content="求道者">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="baobaobao">
<meta name="twitter:description" content="求道者">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'baobaobao'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>baobaobao</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">baobaobao</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/十三 demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/17/十三 demo/" itemprop="url">第十三章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T21:51:41+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/17/十三 demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/17/十三 demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-DOM2级事件处理程序"><a href="#1-DOM2级事件处理程序" class="headerlink" title="(1)DOM2级事件处理程序"></a>(1)DOM2级事件处理程序</h4><p>   “DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()<br>和 removeEventListener()。所有 DOM 节点中都包含这两个方法，并且它们都接受 3 个参数：要处<br>理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获<br>阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。<br>要在按钮上为 click 事件添加事件处理程序，可以使用下列代码：</p>
<pre><code>&lt;body&gt;

    &lt;button&gt;&lt;/button&gt;

    &lt;script&gt;
        var ben = document.getElementById(&quot;myBtn&quot;);
        ben.addEventListener(&quot;click&quot;, function () {

            alert(this.id);
        }, false);
      /*上面的代码为一个按钮添加了 onclick 事件处理程序，而且该事件会在冒泡阶段被触发（因为最
后一个参数是 false）。*/
    &lt;/script&gt;
</code></pre><p> 上面的代码为一个按钮添加了 onclick 事件处理程序，而且该事件会在冒泡阶段被触发（因为最<br>后一个参数是 false）。</p>
<h4 id="2-在不同浏览器中通过能力检测来加减方法处理程序，万金油"><a href="#2-在不同浏览器中通过能力检测来加减方法处理程序，万金油" class="headerlink" title="(2)在不同浏览器中通过能力检测来加减方法处理程序，万金油"></a>(2)在不同浏览器中通过能力检测来加减方法处理程序，万金油</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/十二 demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/17/十二 demo/" itemprop="url">第十二章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T21:46:56+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/17/十二 demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/17/十二 demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-本章因为个人原因先跳过了。有时间再看。"><a href="#1-本章因为个人原因先跳过了。有时间再看。" class="headerlink" title="(1)本章因为个人原因先跳过了。有时间再看。"></a>(1)本章因为个人原因先跳过了。有时间再看。</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/十一 demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/17/十一 demo/" itemprop="url">第十一章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T19:09:27+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/17/十一 demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/17/十一 demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-DOM扩展"><a href="#1-DOM扩展" class="headerlink" title="(1)DOM扩展"></a>(1)DOM扩展</h4><blockquote>
<p>这难道不就是jquery干的事情吗？？</p>
</blockquote>
<pre><code>querySelector()方法
querySelector()方法接收一个 CSS 选择符，返回与该模式匹配的第一个元素，如果没有找到匹
配的元素，返回 null。请看下面的例子。
&lt;html&gt;

&lt;body&gt;

    &lt;body&gt;

        &lt;div id=&quot;myDiv&quot;&gt;
               dlskajflk
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;script&gt;
      var body=document.querySelector(&quot;body&quot;);
      var myDiv=document.querySelector(&quot;#myDiv&quot;);
      alert(myDiv.outerHTML);//输出 &lt;div id=&quot;myDiv&quot;&gt; dlskajflk&lt;/div&gt;
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><h4 id="2-Html5定义了大量的JavaScript的API"><a href="#2-Html5定义了大量的JavaScript的API" class="headerlink" title="(2)Html5定义了大量的JavaScript的API"></a>(2)Html5定义了大量的JavaScript的API</h4><p>  1  比较有特点的是插入标记。可以直接设置一个便签的innerHTML直接插入一些便签。</p>
<pre><code>在读模式下，innerHTML 属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应
的 HTML 标记。在写模式下，innerHTML 会根据指定的值创建新的 DOM 树，然后用这个 DOM 树完全
替换调用元素原先的所有子节点。下面是一个例子。
&lt;div id=&quot;content&quot;&gt;
 &lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt;
 &lt;ul&gt;
 &lt;li&gt;Item 1&lt;/li&gt;
 &lt;li&gt;Item 2&lt;/li&gt;
 &lt;li&gt;Item 3&lt;/li&gt;
 &lt;/ul&gt;
&lt;/div&gt;
对于上面的&lt;div&gt;元素来说，它的 innerHTML 属性会返回如下字符串。
&lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;Item 1&lt;/li&gt;
 &lt;li&gt;Item 2&lt;/li&gt;
 &lt;li&gt;Item 3&lt;/li&gt;
&lt;/ul&gt; 
</code></pre><p>而设置也超级简单。</p>
<blockquote>
<p>  div.innerHTML = “Hello &amp; welcome, <b>\”reader\”!</b>“; </p>
</blockquote>
<h4 id="3-不要频繁使用innerHTML"><a href="#3-不要频繁使用innerHTML" class="headerlink" title="(3)不要频繁使用innerHTML"></a>(3)不要频繁使用innerHTML</h4><pre><code>&lt;html&gt;

&lt;body&gt;

    &lt;body&gt;

        &lt;div id=&quot;myDiv&quot;&gt;
               dlskajflk
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;script&gt;
      for(var i=0,len=values.length;i&lt;len;i++){

        ul.innerHTML+=&quot;&lt;li&gt;&quot;+values[i]+&quot;&lt;/li&gt;&quot;;
      }
   /*这个算法不好，这样会频繁的访问ul.innerHTML，性能很差*/
      var itemsHtml=&quot;&quot;;
      for(var i=0,len=values.length;i&lt;len;i++){
          itemsHtml+=&quot;&lt;li&gt;&quot;+values[i]+&quot;&lt;/li&gt;&quot;;
      }
      ul.innerHTML=itemsHtml;
      /*我们应该不断累加，再一次性加给innerHTML。*/
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><h4 id="4-contains-方法"><a href="#4-contains-方法" class="headerlink" title="(4)contains()方法"></a>(4)contains()方法</h4><p>   在实际开发中，经常需要知道某个节点是不是另一个节点的后代。IE 为此率先引入了 contains()<br>方法，以便不通过在 DOM 文档树中查找即可获得这个信息。调用 contains()方法的应该是祖先节点，<br>也就是搜索开始的节点，这个方法接收一个参数，即要检测的后代节点。如果被检测的节点是后代节点，<br>该方法返回 true；否则，返回 false。以下是一个例子：<br>alert(document.documentElement.contains(document.body)); //true<br>当然，考虑到不同浏览器之间的支持程度。我们可以使用一种通用的函数。比如。  </p>
<pre><code>function contains(refNode, otherNode) {
       if (typeof refNode.contains == &quot;function&quot; &amp;&amp;
           (!client.engine.webkit || client.engine.webkit &gt;= 522)) {
           return refNode.contains(otherNode);
       } else if (typeof refNode.compareDocumentPosition == &quot;function&quot;) {
           return !!(refNode.compareDocumentPosition(otherNode) &amp; 16);
       } else {
           var node = otherNode.parentNode;
           do {
               if (node === refNode) {
                   return true;
               } else {
                   node = node.parentNode;
               }
           } while (node !== null);

           return false;
       }
   } 

   alert(contains(document.getElementById(&quot;myDiv&quot;)),document.getElementById(&quot;myLi&quot;))
</code></pre><h4 id="5-innerText属性"><a href="#5-innerText属性" class="headerlink" title="(5)innerText属性"></a>(5)innerText属性</h4><p>通过 innertText 属性可以操作元素中包含的所有文本内容，包括子文档树中的文本。在通过<br>innerText 读取值时，它会按照由浅入深的顺序，将子文档树中的所有文本拼接起来。在通过<br>innerText 写入值时，<strong>结果会删除元素的所有子节点，插入包含相应文本值的文本节点。</strong>来看下面这<br>个 HTML 代码示例。  </p>
<pre><code>&lt;div id=&quot;content&quot;&gt;
 &lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt;
 &lt;ul&gt;
 &lt;li&gt;Item 1&lt;/li&gt;
 &lt;li&gt;Item 2&lt;/li&gt;
 &lt;li&gt;Item 3&lt;/li&gt;
 &lt;/ul&gt;
&lt;/div&gt;
InnerTextExample01.htm
对于这个例子中的&lt;div&gt;元素而言，其 innerText 属性会返回下列字符串：
This is a paragraph with a list following it.
Item 1
Item 2
Item 3 
</code></pre><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="(6)小结"></a>(6)小结</h4><blockquote>
<ul>
<li>虽然 DOM 为与 XML 及 HTML 文档交互制定了一系列核心 API，但仍然有几个规范对标准的 DOM<br>进行了扩展。这些扩展中有很多原来是浏览器专有的，但后来成为了事实标准，于是其他浏览器也都提<br>供了相同的实现。本章介绍的三个这方面的规范如下。</li>
<li>1 Selectors API，定义了两个方法，让开发人员能够基于 CSS 选择符从 DOM 中取得元素，这两个<br>方法是 querySelector()和 querySelectorAll()。</li>
<li>2 Element Traversal，为 DOM 元素定义了额外的属性，让开发人员能够更方便地从一个元素跳到<br>另一个元素。之所以会出现这个扩展，是因为浏览器处理 DOM 元素间空白符的方式不一样。</li>
<li>HTML5，为标准的 DOM 定义了很多扩展功能。其中包括在 innerHTML 属性这样的事实标准基<br>础上提供的标准定义，以及为管理焦点、设置字符集、滚动页面而规定的扩展 API。<br>虽然目前 DOM 扩展的数量还不多，但随着 Web 技术的发展，相信一定还会涌现出更多扩展来。很<br>多浏览器都在试验专有的扩展，而这些扩展一旦获得认可，就能成为“伪”标准，甚至会被收录到规范<br>的更新版本中。</li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/十 demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/17/十 demo/" itemprop="url">第十章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T13:54:51+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/17/十 demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/17/十 demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-DOM"><a href="#1-DOM" class="headerlink" title="(1)DOM"></a>(1)DOM</h4><p>这一章主要针对不同浏览器要使用功能时做出的检测是否支持这个功能的一章。<br>没啥意思。</p>
<h4 id="2-Document类型"><a href="#2-Document类型" class="headerlink" title="(2)Document类型"></a>(2)Document类型</h4><p>  JavaScript 通过 Document 类型表示文档。在浏览器中，document 对象是 HTMLDocument（继承<br>自 Document 类型）的一个实例，表示整个 HTML 页面。而且，document 对象是 window 对象的一个<br>属性，因此可以将其作为全局对象来访问。<br>通过它可以访问到文档各种信息。 </p>
<pre><code>//取得完整的 URL
 var url = document.URL;
 //取得域名
 var domain = document.domain;
 //取得来源页面的 URL
 var referrer = document.referrer; 
</code></pre><h4 id="3-文档写入"><a href="#3-文档写入" class="headerlink" title="(3)文档写入"></a>(3)文档写入</h4><p>如果想要documen.write来写入我们需要插入到界面的JavaScript代码可以这样。  </p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
document.write(&quot;&lt;script type=\&quot;text/javascript\&quot;   src=\&quot;file.js\&quot; &gt;&quot; +&quot;&lt;\/script&gt;&quot;); 
&lt;/script&gt; 
</code></pre><h4 id="4-node遍历"><a href="#4-node遍历" class="headerlink" title="(4)node遍历"></a>(4)node遍历</h4><blockquote>
<p>不过，如果想要遍历元素的特性，attributes 属性倒是可以派上用场。在需要将 DOM 结构序列<br>化为 XML 或 HTML 字符串时，多数都会涉及遍历元素特性。以下代码展示了如何迭代元素的每一个特<br>性，然后将它们构造成 name=”value” name=”value”这样的字符串格式<br>。  </p>
</blockquote>
<pre><code>function outputAttributes(element){
 var pairs = new Array(),
 attrName,
 attrValue,
 i,
 len;
 for (i=0, len=element.attributes.length; i &lt; len; i++){
 attrName = element.attributes[i].nodeName;
 attrValue = element.attributes[i].nodeValue;
 pairs.push(attrName + &quot;=\&quot;&quot; + attrValue + &quot;\&quot;&quot;);
 }
 return pairs.join(&quot; &quot;);
} 
</code></pre><h4 id="5-遍历元素子节点"><a href="#5-遍历元素子节点" class="headerlink" title="(5)遍历元素子节点"></a>(5)遍历元素子节点</h4><pre><code>&lt;html&gt;

&lt;body&gt;
    &lt;ul id=&quot;myList&quot;&gt;
        &lt;li&gt;jlk&lt;/li&gt;
        &lt;li&gt;jlksdjflk&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        var mylist = document.getElementById(&quot;myList&quot;);

        for (var i = 0, len = mylist.childNodes.length; i &lt; len; i++) {
            if (mylist.childNodes[i].nodeType == 1) {
                alert(mylist.childNodes[i].nodeName);//LI
            }
        }
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><h4 id="6-用js代码实现加载js和css文件"><a href="#6-用js代码实现加载js和css文件" class="headerlink" title="(6)用js代码实现加载js和css文件"></a>(6)用js代码实现加载js和css文件</h4><p>比如在同级目录下有一个demo.js文件，我们不想用标签引用，只想用代码引入。我们可以</p>
<pre><code>function loadScript(url){
       var script=document.createElement(&quot;script&quot;);
       script.type=&quot;text/javascript&quot;;
       script.src=url;
       document.body.appendChild(script);
   }
   loadScript(&quot;demo.js&quot;);

    /*需要注意的是，必须将&lt;link&gt;元素添加到&lt;head&gt;
    而不是&lt;body&gt;元素，才能保证在所有浏览器中的行为一致。整个过程可以用以下函数来表示：*/
    function loadStyles(url){
     var link = document.createElement(&quot;link&quot;);
     link.rel = &quot;stylesheet&quot;;
     link.type = &quot;text/css&quot;;
     link.href = url;
     var head = document.getElementsByTagName(&quot;head&quot;)[0];
     head.appendChild(link);
    }
    调用 loadStyles()函数的代码如下所示：
    loadStyles(&quot;styles.css&quot;); 
</code></pre><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="(7)小结"></a>(7)小结</h4><pre><code>  DOM 是语言中立的 API，用于访问和操作 HTML 和 XML 文档。DOM1 级将 HTML 和 XML 文档
形象地看作一个层次化的节点树，可以使用 JavaScript 来操作这个节点树，进而改变底层文档的外观和
结构。
  DOM 由各种节点构成，简要总结如下。
1 最基本的节点类型是 Node，用于抽象地表示文档中一个独立的部分；所有其他类型都继承自
Node。
2 Document 类型表示整个文档，是一组分层节点的根节点。在 JavaScript 中，document 对象是
Document 的一个实例。使用 document 对象，有很多种方式可以查询和取得节点。
3 Element 节点表示文档中的所有 HTML 或 XML 元素，可以用来操作这些元素的内容和特性。
4 另外还有一些节点类型，分别表示文本内容、注释、文档类型、CDATA 区域和文档片段。
访问 DOM 的操作在多数情况下都很直观，不过在处理&lt;script&gt;和&lt;style&gt;元素时还是存在一些
复杂性。由于这两个元素分别包含脚本和样式信息，因此浏览器通常会将它们与其他元素区别对待。这
些区别导致了在针对这些元素使用 innerHTML 时，以及在创建新元素时的一些问题。
理解 DOM 的关键，就是理解 DOM 对性能的影响。DOM 操作往往是 JavaScript 程序中开销最大的
部分，而因访问 NodeList 导致的问题为最多。NodeList 对象都是“动态的”，这就意味着每次访问
NodeList 对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少 DOM 操作。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/九 demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/17/九 demo/" itemprop="url">第九章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T13:47:11+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/17/九 demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/17/九 demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-客户端检测"><a href="#1-客户端检测" class="headerlink" title="(1)客户端检测"></a>(1)客户端检测</h4><p>这一章主要针对不同浏览器要使用功能时做出的检测是否支持这个功能的一章。<br>没啥意思。</p>
<h4 id="2-小结"><a href="#2-小结" class="headerlink" title="(2)小结"></a>(2)小结</h4><pre><code>   客户端检测是 JavaScript 开发中最具争议的一个话题。由于浏览器间存在差别，通常需要根据不同
浏览器的能力分别编写不同的代码。有不少客户端检测方法，但下列是最经常使用的。
1  能力检测：在编写代码之前先检测特定浏览器的能力。例如，脚本在调用某个函数之前，可能
要先检测该函数是否存在。这种检测方法将开发人员从考虑具体的浏览器类型和版本中解放出
来，让他们把注意力集中到相应的能力是否存在上。能力检测无法精确地检测特定的浏览器和
版本。

2    怪癖检测：怪癖实际上是浏览器实现中存在的 bug，例如早期的 WebKit 中就存在一个怪癖，即
它会在 for-in 循环中返回被隐藏的属性。怪癖检测通常涉及到运行一小段代码，然后确定浏
览器是否存在某个怪癖。由于怪癖检测与能力检测相比效率更低，因此应该只在某个怪癖会干
扰脚本运行的情况下使用。怪癖检测无法精确地检测特定的浏览器和版本。

3   用户代理检测：通过检测用户代理字符串来识别浏览器。用户代理字符串中包含大量与浏览器
有关的信息，包括浏览器、平台、操作系统及浏览器版本。用户代理字符串有过一段相当长的
发展历史，在此期间，浏览器提供商试图通过在用户代理字符串中添加一些欺骗性信息，欺骗
网站相信自己的浏览器是另外一种浏览器。用户代理检测需要特殊的技巧，特别是要注意 Opera
会隐瞒其用户代理字符串的情况。即便如此，通过用户代理字符串仍然能够检测出浏览器所用
的呈现引擎以及所在的平台，包括移动设备和游戏系统。
   在决定使用哪种客户端检测方法时，一般应优先考虑使用能力检测。怪癖检测是确定应该如何处理
代码的第二选择。而用户代理检测则是客户端检测的最后一种方案，因为这种方法对用户代理字符串具
有很强的依赖性。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/八 demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/17/八 demo/" itemprop="url">第八章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T11:49:20+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/17/八 demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/17/八 demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-window对象以及窗口框架"><a href="#1-window对象以及窗口框架" class="headerlink" title="(1) window对象以及窗口框架"></a>(1) window对象以及窗口框架</h4><blockquote>
<p>由于 window 对象同时扮演着 ECMAScript 中 Global 对象的角色，因此所有在全局作用域中声明<br>的变量、函数都会变成 window 对象的属性和方法。</p>
</blockquote>
<h4 id="2-窗口位置相对于top的位置"><a href="#2-窗口位置相对于top的位置" class="headerlink" title="(2) 窗口位置相对于top的位置"></a>(2) 窗口位置相对于top的位置</h4><pre><code>var leftPos=(typeof window.screenLeft==&apos;number&apos;)?
     window.screenLeft:window.screenX;
     alert(leftPos);
</code></pre><h4 id="3-检查弹出窗口是否被屏蔽了"><a href="#3-检查弹出窗口是否被屏蔽了" class="headerlink" title="(3)检查弹出窗口是否被屏蔽了"></a>(3)检查弹出窗口是否被屏蔽了</h4><p>如果浏览器扩展或者其他程序阻止弹出窗口的话。我们用try catch来判断</p>
<pre><code>var blocked = false;
try {
    var wrpxWin = window.open(&quot;http://www.wrox.com&quot;, &quot;_blank&quot;); if (wrpxWin == null) {
        blocked = true;//窗口被屏蔽了
    }
} catch (ex) {
    blocked = true;
}

if (blocked) {
    alert(&quot;the popupp was bolcked!&quot;);
}
</code></pre><h4 id="4-对话框"><a href="#4-对话框" class="headerlink" title="(4) 对话框"></a>(4) 对话框</h4><blockquote>
<ul>
<li>alert</li>
<li>confirm</li>
<li>prompt  </li>
</ul>
</blockquote>
<p>重点是第三种，让你输入一个对话框，并要求你输入数据。</p>
<pre><code> var result = prompt(&quot;what is you name?&quot;, &quot;&quot;);
 if (result != null) {
    alert(&quot;Welcome,&quot; + result);
}
</code></pre><h4 id="5-location对象"><a href="#5-location对象" class="headerlink" title="(5) location对象"></a>(5) location对象</h4><blockquote>
<p>location 是最有用的 BOM 对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一<br>些导航功能。事实上，location 对象是很特别的一个对象，因为它既是 window 对象的属性，也是<br>document 对象的属性；换句话说，window.location 和 document.location 引用的是同一个对象。<br>location 对象的用处不只表现在它保存着当前文档的信息，还表现在它将 URL 解析为独立的片段，让<br>开发人员可以通过不同的属性访问这些片段。</p>
</blockquote>
<h4 id="6-navigator对象-检测插件"><a href="#6-navigator对象-检测插件" class="headerlink" title="(6) navigator对象 检测插件"></a>(6) navigator对象 检测插件</h4><pre><code>function hasPlugin(name) {
    name = name.toLowerCase();
    for (var i = 0; i &lt; navigator.plugins.length; i++) {
        if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1) {
            return true;
        }
        return false;
    }
}
alert(hasPlugin(&quot;Flash&quot;));//检查是否有Flash插件
</code></pre><h4 id="6-history对象"><a href="#6-history对象" class="headerlink" title="(6) history对象"></a>(6) history对象</h4><blockquote>
<p>浏览器内置对象，可以用它模仿前一个界面，后一个界面操作。</p>
</blockquote>
<h4 id="7-小结"><a href="#7-小结" class="headerlink" title="(7) 小结"></a>(7) 小结</h4><pre><code>   浏览器对象模型（BOM）以 window 对象为依托，表示浏览器窗口以及页面可见区域。同时，window
对象还是 ECMAScript 中的 Global 对象，因而所有全局变量和函数都是它的属性，且所有原生的构造
函数及其他函数也都存在于它的命名空间下。本章讨论了下列 BOM 的组成部分。
1 在使用框架时，每个框架都有自己的 window 对象以及所有原生构造函数及其他函数的副本。
每个框架都保存在 frames 集合中，可以通过位置或通过名称来访问。
2 有一些窗口指针，可以用来引用其他框架，包括父框架。
3 top 对象始终指向最外围的框架，也就是整个浏览器窗口。
4 parent 对象表示包含当前框架的框架，而 self 对象则回指 window。
5 使用 location 对象可以通过编程方式来访问浏览器的导航系统。设置相应的属性，可以逐段
或整体性地修改浏览器的 URL。
6 调用 replace()方法可以导航到一个新 URL，同时该 URL 会替换浏览器历史记录中当前显示
的页面。
7 *navigator 对象提供了与浏览器有关的信息。到底提供哪些信息，很大程度上取决于用户的浏
览器；不过，也有一些公共的属性（如 userAgent）存在于所有浏览器中。
BOM 中还有两个对象：screen 和 history，但它们的功能有限。screen 对象中保存着与客户端
显示器有关的信息，这些信息一般只用于站点分析。history 对象为访问浏览器的历史记录开了一个
小缝隙，开发人员可以据此判断历史记录的数量，也可以在历史记录中向后或向前导航到任意页面。*
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/七 demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/17/七 demo/" itemprop="url">第七章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T11:24:14+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/17/七 demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/17/七 demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-访问器属性"><a href="#1-访问器属性" class="headerlink" title="(1) 访问器属性"></a>(1) 访问器属性</h4><pre><code>    var book={};
Object.defineProperties(book,{
   _year:{
       writable:true,
       value:2014
   }
})

/*以上的Object.defineProperties可以给book对象的加属性以及以及对属性的操作等*/
//当然，也可以读取属性的特性。
var descriptor=Object.getOwnPropertyDescriptor(book,&quot;_year&quot;);
alert(descriptor.value);  //2014
alert(descriptor.configurable);  //false
</code></pre><h4 id="2-在对象和原型中查找属性或者方法的顺序。"><a href="#2-在对象和原型中查找属性或者方法的顺序。" class="headerlink" title="(2) 在对象和原型中查找属性或者方法的顺序。"></a>(2) 在对象和原型中查找属性或者方法的顺序。</h4><blockquote>
<p>如果按照字面意思来理解，那<br>么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以<br>让所有对象实例共享它所包含的属性和方法。</p>
</blockquote>
<blockquote>
<p>.hasOwnProperty方法可以用来检查某个属性在实例中还是原型中。</p>
</blockquote>
<p>同时使用 hasOwnProperty()方法和 in 操作符，就可以确定该属性到底是存在于对象中，还是存在于<br>原型中，如下所示。  </p>
<pre><code> //这个函数实现认识某个属性在不在原型中，在的话，返回ture，否则返回false；
function hasPrototypeProperty(object, name) {
    return !object.hasOwnProperty(name) &amp;&amp; (name in object);
}
function Person() {
}
Person.prototype.name = &quot;nihao&quot;;
var person = new Person();
alert(hasPrototypeProperty(person, &quot;name&quot;));  //ture,表明name在原型中。
person.name = &quot;goobye&quot;;
alert(hasPrototypeProperty(person, &quot;name&quot;));  //false，不在原型中
</code></pre><h4 id="3-组合使用构造函数和原型模式"><a href="#3-组合使用构造函数和原型模式" class="headerlink" title="(3)组合使用构造函数和原型模式"></a>(3)组合使用构造函数和原型模式</h4><blockquote>
<p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实<br>例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，<br>但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参<br>数；可谓是集两种模式之长。下面的代码重写了前面的例子。  </p>
</blockquote>
<pre><code>/*构造函数用于实例化属性*/
    function Person(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.friends = [&apos;nihao&apos;, &quot;goobye&quot;];
    }


    /*原型模式用于定义方法和共享的属性*/
    Person.prototype = {
        constructor: Person,
        sayName: function () {

            alert(this.name);
        }
    }

    var person1 = new Person(&quot;nihao&quot;, 29, &quot;software Engineer&quot;)

    alert(person1.name);//nihao
</code></pre><h4 id="4-原型链"><a href="#4-原型链" class="headerlink" title="(4) 原型链"></a>(4) 原型链</h4><blockquote>
<ul>
<li>子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎<br>样，给原型添加方法的代码一定要放在替换原型的语句之后。</li>
</ul>
</blockquote>
<pre><code>function SuperType() {

      this.property = true;
  }
  SuperType.prototype.getSuperValue = function () {
      return this.property;
  }

  function SubType() {

      this.subproperty = false;
  }


  //继承实现
  SubType.prototype = new SuperType();
  //添加新方法
  SubType.prototype.getSubValue = function () {
      return his.subproperty;
  }
  //重写超类型方法
  SubType.prototype.getSuperValue = function () {

      return false;
  }
  var instanc = new SubType();
  alert(instanc.getSuperValue());  //false
</code></pre><h4 id="5-原型继承的问题以及解决"><a href="#5-原型继承的问题以及解决" class="headerlink" title="(5) 原型继承的问题以及解决"></a>(5) 原型继承的问题以及解决</h4><blockquote>
<p>它的问题就是当一个子类继承父类的时候，当定义子类对象时。子类某一个对象对父类中属性或者方法的改动都会反映到子类的其他对象中，<br>因为父类成了子类定义对象的原型。其他对象使用后也会有相应改变。那么可以使用借用构造函数来解决。  </p>
</blockquote>
<p>借用构造函数    </p>
<pre><code>function SuperType() {
     this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
 }
 function SubType() {
     //继承了Suptype
     SuperType.call(this);
 }

 var instance1 = new SubType();
 instance1.colors.push(&quot;black&quot;);//&quot;red,blue,green,black&quot; 
 alert(instance1.colors);
 var instance2 = new SubType();
 alert(instance2.colors);  //&quot;red,blue,green&quot; ,现在每个子类对象就保持了自己对父类的最初属性了。
</code></pre><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="(6) 小结"></a>(6) 小结</h4><blockquote>
<pre><code> ECMAScript 支持面向对象（OO）编程，但不使用类或者接口。对象可以在代码执行过程中创建和
 增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。
 1   工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来
 被构造函数模式所取代。
 2   构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用 new 操作符。不
 过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局
限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。
 3   原型模式，使用构造函数的 prototype 属性来指定那些应该共享的属性和方法。组合使用构造
 函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。
  JavaScript 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函
 数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。
 原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借
 用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的
 属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用
 原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。
 此外，还存在下列可供选择的继承模式。
 4   原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅
 复制。而复制得到的副本还可以得到进一步改造。
 5 寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强
 对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问
 题，可以将这个模式与组合继承一起使用。
 6  寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。
</code></pre></blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/六 demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/17/六 demo/" itemprop="url">第六章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T09:30:47+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/17/六 demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/17/六 demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-访问器属性"><a href="#1-访问器属性" class="headerlink" title="(1) 访问器属性"></a>(1) 访问器属性</h4><pre><code>    var book={};
Object.defineProperties(book,{
   _year:{
       writable:true,
       value:2014
   }
})

/*以上的Object.defineProperties可以给book对象的加属性以及以及对属性的操作等*/
//当然，也可以读取属性的特性。
var descriptor=Object.getOwnPropertyDescriptor(book,&quot;_year&quot;);
alert(descriptor.value);  //2014
alert(descriptor.configurable);  //false
</code></pre><h4 id="2-在对象和原型中查找属性或者方法的顺序。"><a href="#2-在对象和原型中查找属性或者方法的顺序。" class="headerlink" title="(2) 在对象和原型中查找属性或者方法的顺序。"></a>(2) 在对象和原型中查找属性或者方法的顺序。</h4><blockquote>
<p>如果按照字面意思来理解，那<br>么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以<br>让所有对象实例共享它所包含的属性和方法。</p>
</blockquote>
<blockquote>
<p>.hasOwnProperty方法可以用来检查某个属性在实例中还是原型中。</p>
</blockquote>
<p>同时使用 hasOwnProperty()方法和 in 操作符，就可以确定该属性到底是存在于对象中，还是存在于<br>原型中，如下所示。  </p>
<pre><code> //这个函数实现认识某个属性在不在原型中，在的话，返回ture，否则返回false；
function hasPrototypeProperty(object, name) {
    return !object.hasOwnProperty(name) &amp;&amp; (name in object);
}
function Person() {
}
Person.prototype.name = &quot;nihao&quot;;
var person = new Person();
alert(hasPrototypeProperty(person, &quot;name&quot;));  //ture,表明name在原型中。
person.name = &quot;goobye&quot;;
alert(hasPrototypeProperty(person, &quot;name&quot;));  //false，不在原型中
</code></pre><h4 id="3-组合使用构造函数和原型模式"><a href="#3-组合使用构造函数和原型模式" class="headerlink" title="(3)组合使用构造函数和原型模式"></a>(3)组合使用构造函数和原型模式</h4><blockquote>
<p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实<br>例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，<br>但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参<br>数；可谓是集两种模式之长。下面的代码重写了前面的例子。  </p>
</blockquote>
<pre><code>/*构造函数用于实例化属性*/
    function Person(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.friends = [&apos;nihao&apos;, &quot;goobye&quot;];
    }


    /*原型模式用于定义方法和共享的属性*/
    Person.prototype = {
        constructor: Person,
        sayName: function () {

            alert(this.name);
        }
    }

    var person1 = new Person(&quot;nihao&quot;, 29, &quot;software Engineer&quot;)

    alert(person1.name);//nihao
</code></pre><h4 id="4-原型链"><a href="#4-原型链" class="headerlink" title="(4) 原型链"></a>(4) 原型链</h4><blockquote>
<ul>
<li>子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎<br>样，给原型添加方法的代码一定要放在替换原型的语句之后。</li>
</ul>
</blockquote>
<pre><code>function SuperType() {

      this.property = true;
  }
  SuperType.prototype.getSuperValue = function () {
      return this.property;
  }

  function SubType() {

      this.subproperty = false;
  }


  //继承实现
  SubType.prototype = new SuperType();
  //添加新方法
  SubType.prototype.getSubValue = function () {
      return his.subproperty;
  }
  //重写超类型方法
  SubType.prototype.getSuperValue = function () {

      return false;
  }
  var instanc = new SubType();
  alert(instanc.getSuperValue());  //false
</code></pre><h4 id="5-原型继承的问题以及解决"><a href="#5-原型继承的问题以及解决" class="headerlink" title="(5) 原型继承的问题以及解决"></a>(5) 原型继承的问题以及解决</h4><blockquote>
<p>它的问题就是当一个子类继承父类的时候，当定义子类对象时。子类某一个对象对父类中属性或者方法的改动都会反映到子类的其他对象中，<br>因为父类成了子类定义对象的原型。其他对象使用后也会有相应改变。那么可以使用借用构造函数来解决。  </p>
</blockquote>
<p>借用构造函数    </p>
<pre><code>function SuperType() {
     this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
 }
 function SubType() {
     //继承了Suptype
     SuperType.call(this);
 }

 var instance1 = new SubType();
 instance1.colors.push(&quot;black&quot;);//&quot;red,blue,green,black&quot; 
 alert(instance1.colors);
 var instance2 = new SubType();
 alert(instance2.colors);  //&quot;red,blue,green&quot; ,现在每个子类对象就保持了自己对父类的最初属性了。
</code></pre><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="(6) 小结"></a>(6) 小结</h4><blockquote>
<pre><code> ECMAScript 支持面向对象（OO）编程，但不使用类或者接口。对象可以在代码执行过程中创建和
 增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。
 1   工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来
 被构造函数模式所取代。
 2   构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用 new 操作符。不
 过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局
限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。
 3   原型模式，使用构造函数的 prototype 属性来指定那些应该共享的属性和方法。组合使用构造
 函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。
  JavaScript 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函
 数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。
 原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借
 用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的
 属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用
 原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。
 此外，还存在下列可供选择的继承模式。
 4   原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅
 复制。而复制得到的副本还可以得到进一步改造。
 5 寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强
 对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问
 题，可以将这个模式与组合继承一起使用。
 6  寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。
</code></pre></blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/16/五  demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/16/五  demo/" itemprop="url">第五章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-16T16:37:06+08:00">
                2018-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/16/五  demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/16/五  demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-引用类型"><a href="#1-引用类型" class="headerlink" title="(1) 引用类型"></a>(1) 引用类型</h4><p>  在 ECMAScript 中，引用类型是一种数据结构。<br>用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管 ECMAScript<br>从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基<br>本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。</p>
<h4 id="2-object定义"><a href="#2-object定义" class="headerlink" title="(2) object定义"></a>(2) object定义</h4><p>推荐定义object用字面量定义    </p>
<pre><code>var person = {    
 name : &quot;Nicholas&quot;,  
 age : 29  
};   
var person = {}; //与 new Object()相同  
person.name = &quot;Nicholas&quot;;  
person.age = 29;   
</code></pre><h4 id="3-array定义推荐"><a href="#3-array定义推荐" class="headerlink" title="(3)array定义推荐"></a>(3)array定义推荐</h4><pre><code>var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含 3 个字符串的数组  
var names = []; // 创建一个空数组 ,用它即可。 
var values = [1,2,]; // 不要这样！这样会创建一个包含 2 或 3 项的数组  
var options = [,,,,,]; // 不要这样！这样会创建一个包含 5 或 6 项的数组 
</code></pre><p>一些知识点</p>
<pre><code>/*1 动态给数组加数据，类似于线性表了。*/
var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含 3 个字符串的数组  
colors[colors.length] = &quot;black&quot;; //（在位置 3）添加一种颜色  
colors[colors.length] = &quot;brown&quot;; //（在位置 4）再添加一种颜色
/*2 数组的toLocaleString（）方法，其实是调用每一项的toString方法，输出。*/    
/*数组的栈以及队列方法  
push，pop，shift    
其中push和shift结合可以实现队列方法。*/ 
 var colors=new Array();    
     var count=colors.push(&quot;red&quot;,&quot;green&quot;);  //这个函数调用会返回2，有意思  
       alert(count);  
       count=colors.push(&quot;black&quot;);  
       alert(count);  
       var item=colors.shift();  //取得第一项,厉害了  
       alert(item);
</code></pre><h4 id="4-数组的迭代方法"><a href="#4-数组的迭代方法" class="headerlink" title="(4) 数组的迭代方法"></a>(4) 数组的迭代方法</h4><blockquote>
<ul>
<li>every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。</li>
<li>filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</li>
<li>forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。</li>
<li>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li>some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。<br>以上方法都不会修改数组中的包含的值。<br>在这些方法中，最相似的是 every()和 some()，它们都用于查询数组中的项是否满足某个条件。<br>对 every()来说，传入的函数必须对每一项都返回 true，这个方法才返回 true；否则，它就返回<br>false。而 some()方法则是只要传入的函数对数组中的某一项返回 true，就会返回 true。请看以下<br>例子。</li>
</ul>
</blockquote>
<pre><code>var numbers = [1, 2, 4, 343, 43, 423, 4];    
       var everyResult = numbers.every(function (item, index, array) {  
        return (item&gt;2)
       })
   alert(everyResult);  //false,他要求所有item都&gt;2才可以。
   var evetyResultq=numbers.some(function(item,index,array){  
   return  (item&gt;2)
   })
   alert(everyResult);//ture，他只要求其中有一个到几个&gt;2即可。
var filteResult=numbers.filter(function(item,index,array){
       return (item&gt;2);
   })
   alert(filteResult)  //返回这个数组所有大于2的数，并组成一个数组，这个牛逼了
</code></pre><h4 id="5-作为值的函数"><a href="#5-作为值的函数" class="headerlink" title="(5) 作为值的函数"></a>(5) 作为值的函数</h4><pre><code>/*因为 ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以  
像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。来看  
一看下面的函数。*/
  function callSomeFunction(someFunction, someArgument) {  
        return someFunction(someArgument);  //函数返回一个值，这个值就是一个函数
    }
    function add10num(num) {
        return num + 10;
    }
    var result = callSomeFunction(add10num, 10);
    alert(result);//20
</code></pre><h4 id="6-作为值的函数以及call"><a href="#6-作为值的函数以及call" class="headerlink" title="(6) 作为值的函数以及call"></a>(6) 作为值的函数以及call</h4><pre><code>  function callSomeFunction(someFunction, someArgument) {
      return someFunction(someArgument);  //函数返回一个值，这个值就是一个函数
  }
  function add10num(num) {
      return num + 10;
  }
  var result = callSomeFunction(add10num, 10);
  alert(result);//20
window.color = &quot;red&quot;;
  var o = { color: &quot;blue&quot; };
  function sayColor() {
      alert(this.color);
  }
  sayColor();
  sayColor.call(this);//red,这是全局变量使用
  sayColor.call(o);//blue，call可以帮我们指定this对象所指向的位置。完美
</code></pre><h4 id="7-基本包装类型的生存期以及后台解析成对象"><a href="#7-基本包装类型的生存期以及后台解析成对象" class="headerlink" title="(7)基本包装类型的生存期以及后台解析成对象"></a>(7)基本包装类型的生存期以及后台解析成对象</h4><pre><code>var s1=&quot;some text&quot;;
var s2=s1.substring(2);
/*后台其实是执行了这样的一个过程

(1) 创建 String 类型的一个实例；
(2) 在实例上调用指定的方法；
(3) 销毁这个实例。
可以将以上三个步骤想象成是执行了下列 ECMAScript 代码。
var s1 = new String(&quot;some text&quot;);
var s2 = s1.substring(2);
s1 = null;
经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于 Boolean
和 Number 类型对应的布尔值和数字值。
引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例，
在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一
行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。如下代码所示
 */

var s1 = &quot;some text&quot;;
s1.color = &quot;red&quot;;
alert(s1.color); //undefined
</code></pre><h4 id="（8）单体内置对象Global对象"><a href="#（8）单体内置对象Global对象" class="headerlink" title="（8）单体内置对象Global对象"></a>（8）单体内置对象Global对象</h4><blockquote>
<p>不属于任何其他对象的属性和方法，最终都是Global对象中的属性和方法。<br>winow对象,  </p>
</blockquote>
<p>  ECMAScript 虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是将这个全局对象作为<br>window 对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了 window<br>对象的属性。来看下面的例子。  </p>
<pre><code>var color = &quot;red&quot;;
function sayColor(){
 alert(window.color);
}
window.sayColor(); //&quot;red&quot; 
</code></pre><h4 id="（9）小结"><a href="#（9）小结" class="headerlink" title="（9）小结"></a>（9）小结</h4><pre><code>对象在 JavaScript 中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象，
现简要总结如下：
1 引用类型与传统面向对象程序设计中的类相似，但实现不同；
2 Object 是一个基础类型，其他所有类型都从 Object 继承了基本的行为；
3 Array 类型是一组值的有序列表，同时还提供了操作和转换这些值的功能；
4  Date 类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能；
5 RegExp 类型是 ECMAScript 支持正则表达式的一个接口，提供了最基本的和一些高级的正则表
达式功能。
函数实际上是 Function 类型的实例，因此函数也是对象；而这一点正是 JavaScript 最有特色的地
方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。
因为有了基本包装类型，所以 JavaScript 中的基本类型值可以被当作对象来访问。三种基本包装类
型分别是：Boolean、Number 和 String。以下是它们共同的特征：
6 每个包装类型都映射到同名的基本类型；
7 在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据
操作；
8 操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。
在所有代码执行之前，作用域中就已经存在两个内置对象：Global 和 Math。在大多数 ECMAScript
实现中都不能直接访问 Global 对象；不过，Web 浏览器实现了承担该角色的 window 对象。全局变
量和函数都是 Global 对象的属性。Math 对象提供了很多属性和方法，用于辅助完成复杂的数学计算
任务。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/16/四  demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/16/四  demo/" itemprop="url">第四章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-16T15:56:19+08:00">
                2018-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/16/四  demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/16/四  demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-访问变量有基本类型与引用类型"><a href="#1-访问变量有基本类型与引用类型" class="headerlink" title="(1) 访问变量有基本类型与引用类型"></a>(1) 访问变量有基本类型与引用类型</h4><p>  你不能给基本类型加属性和方法，但是引用类型可以。如果你给一个引用类型<br>加了属性和方法，另一个也会有，其实他们之间都是地址传递。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">在JavaScript中，参数都是按值传递的。但是，向函数传递基本类型的值时  </span><br><span class="line">它会复制并传递。而传引用类型的参数，直接都是传送地址，会同时反映到该引用上。  </span><br><span class="line">  /*基本类型传递*/  </span><br><span class="line">    function   addTe(num)&#123;  </span><br><span class="line">        num+=10;  </span><br><span class="line">        return num;  </span><br><span class="line">    &#125;  </span><br><span class="line">    var numbe=10;  </span><br><span class="line">    alert(addTe(numbe));//30  </span><br><span class="line">    alert(numbe); //还是10  </span><br><span class="line"></span><br><span class="line">/*引用类型传递*/  </span><br><span class="line">function setName(boj)&#123;  </span><br><span class="line">    obj.name=&quot;nihao&quot;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"> var person=new Object();  </span><br><span class="line"> setName(person);  </span><br><span class="line"> alert(person.name);  //“nihao”</span><br></pre></td></tr></table></figure></p>
<h4 id="2-检测类型"><a href="#2-检测类型" class="headerlink" title="(2)  检测类型"></a>(2)  检测类型</h4><p>多用instanceof，但是他不能检测object<br>如果变量是给定引用类型（根据它的原型链来识别；第 6 章将介绍原型链的实例那么<br>instanceof 操作符就会返回 true。<br>请看下面的例子：<br>alert(person instanceof Object); // 变量 person 是 Object 吗？<br>alert(colors instanceof Array); // 变量 colors 是 Array 吗？<br>alert(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？<br>根据规定，<em>所有引用类型的值都是 Object 的实例</em>。因此，在检测一个引用类型值和 Object 构造<br>函数时，instanceof 操作符始终会返回 true。当然如果使用 instanceof 操作符检测基本类型的<br>值，则该操作符始终会返回 false，因为基本类型不是对象。  </p>
<h4 id="3-垃圾收集机制"><a href="#3-垃圾收集机制" class="headerlink" title="(3) 垃圾收集机制"></a>(3) 垃圾收集机制</h4><p>1  标记清楚收集方式,用一个标志位来标记变量何时“进环境”，何时“出环境”<br>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方<br>式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记<br>的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器<br>完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。<br>2  引用计数方式<br>3  管理内存，当不再使用一个变量时，请手动设置其为null</p>
<h4 id="4-小结"><a href="#4-小结" class="headerlink" title="(4) 小结"></a>(4) 小结</h4><p>JavaScript 变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下 5<br>种基本数据类型：Undefined、Null、Boolean、Number 和 String。基本类型值和引用类型值具<br>有以下特点：  </p>
<blockquote>
<ul>
<li>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；  </li>
<li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；  </li>
<li>引用类型的值是对象，保存在<em>堆内存</em>中；  </li>
<li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；</li>
<li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同<br>一个对象；</li>
<li>确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用<br>instanceof 操作符。<br>所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执<br>行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几<br>点总结：  </li>
<li>执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；  </li>
<li>每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；  </li>
<li>函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全<br>局环境；  </li>
<li>全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；  </li>
<li>变量的执行环境有助于确定应该何时释放内存。<br>JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可<br>以对 JavaScript 的垃圾收集例程作如下总结。  </li>
<li>离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。  </li>
<li>“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然<br>后再回收其内存。  </li>
<li>另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript<br>引擎目前都不再使用这种算法；但在 IE 中访问非原生 JavaScript 对象（如 DOM 元素）时，这种<br>算法仍然可能会导致问题。  </li>
<li>当代码中存在循环引用现象时，“引用计数”算法就会导致问题。</li>
<li>解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回<br>收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。</li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar1.jpg"
                alt="鲍志强" />
            
              <p class="site-author-name" itemprop="name">鲍志强</p>
              <p class="site-description motion-element" itemprop="description">求道者</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/baobaobaobaobao" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="530420396@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/bao-zhi-qiang-2/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">baobaobao</span>

  
</div>






  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  







  
  





  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_sphere.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://baobaobao.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
