<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="baobaobao" />










<meta name="description" content="求道者">
<meta property="og:type" content="website">
<meta property="og:title" content="baobaobao">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="baobaobao">
<meta property="og:description" content="求道者">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="baobaobao">
<meta name="twitter:description" content="求道者">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'baobaobao'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/"/>





  <title>baobaobao</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">baobaobao</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="http://www.scholat.com/zqbao" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于他
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            博客分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            博客归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/20/javascript高级程序设计/十四 demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/20/javascript高级程序设计/十四 demo/" itemprop="url">第十四章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-20T08:15:39+08:00">
                2018-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/20/javascript高级程序设计/十四 demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/20/javascript高级程序设计/十四 demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-表单之阻止表单提交"><a href="#1-表单之阻止表单提交" class="headerlink" title="(1)表单之阻止表单提交"></a>(1)表单之阻止表单提交</h4><p>Html<br>         <form id="myform"></form></p>
<pre><code>&lt;/form&gt;
</code></pre><p>Javascript可以阻止我们表单提交等等。  </p>
<pre><code>          var EventUtil = {
        addHandler: function (element, type, handler) {
            if (element.addEventListener) {
                element.addEventListener(type, handler, false);
            } else if (element.attachEvent) {
                element.attachEvent(&quot;on&quot; + type, handler);
            } else {
                element[&quot;on&quot; + type] = handler;
            }

        },
        getEvent: function (event) {
            return event ? event : window.event;
        },
        getTarget: function (event) {
            return event.target || event.srcElement;
        },

        preventDefault: function (event) {
            if (event.preventDefault) {
                event.preventDefault();
            } else {
                event.returnValue = false;
            }
        },

        removeHandler: function (element, type, handler) {
            if (element.removeEventListener) {
                element.removeEventListener(type, handler, false);
            } else if (element.detachEvent) {
                element.detachEvent(&quot;on&quot; + type, handler);
            } else {
                element[&quot;on&quot; + type] = null;
            }

        },
        stopPropagation: function (event) {
            if (event.stopPropagation) {
                event.stopPropagation();
            } else {
                event.cancelBubble = true;
            }
        }，
getCharCode: function (event) {
                if (typeof event.charCode == &quot;number&quot;) {
                    return event.charCode;
                } else {
                    return event.keyCode;
                }
            }
    };

    var myform=document.getElementById(&quot;myform&quot;);
    EventUtil.addHandler(myform,&quot;submit&quot;,function(event){

        event=EventUtil.getEvent(event);
        //阻止默认事件
        EventUtil.preventDefault(event);
    })
</code></pre><h4 id="2-阻止表单进行重置"><a href="#2-阻止表单进行重置" class="headerlink" title="(2)阻止表单进行重置"></a>(2)阻止表单进行重置</h4><p>Html  </p>
<input type="reset" value="Reset Form"> 

<p>当点击reset按钮时我们可以用代码来阻止重置。<br>JavaScript  </p>
<pre><code>var form = document.getElementById(&quot;myForm&quot;);
EventUtil.addHandler(form, &quot;reset&quot;, function(event){
 //取得事件对象
 event = EventUtil.getEvent(event);
 //阻止表单重置
 EventUtil.preventDefault(event);
}); 
</code></pre><h4 id="3-一些属性"><a href="#3-一些属性" class="headerlink" title="(3)一些属性"></a>(3)一些属性</h4><p>Html  </p>
<pre><code>&lt;form id=&quot;myform&quot;&gt;
       &lt;input /&gt;
       &lt;input name=&quot;nihao&quot;/&gt;
 &lt;/form&gt;
</code></pre><p>JavaScript  </p>
<pre><code>var form = document.getElementById(&quot;myform&quot;);
//取得表单中的第一个字段
var field1 = form.elements[0];
//取得名为&quot;nihao&quot;的字段
var field2 = form.elements[&quot;nihao&quot;];
field2.value=&quot;nihao&quot;;
//取得表单中包含的字段的数量
var fieldCount = form.elements.length;  
alert(fieldCount);  
我们以此给了btn加了三个事件。只用了一个函数。
</code></pre><h4 id="4-避免重复提交"><a href="#4-避免重复提交" class="headerlink" title="(4)避免重复提交"></a>(4)避免重复提交</h4><p>  能够动态修改表单字段属性，意味着我们可以在任何时候，以任何方式来动态操作表单。例如，很<br>多用户可能会重复单击表单的提交按钮。在涉及信用卡消费时，这就是个问题：因为会导致费用翻番。<br>为此，最常见的解决方案，就是在第一次单击后就禁用提交按钮。只要侦听 submit 事件，并在该事件<br>发生时禁用提交按钮即可。以下就是这样一个例子。  </p>
<pre><code>//避免多次提交表单
EventUtil.addHandler(form, &quot;submit&quot;, function(event){
 event = EventUtil.getEvent(event);
 var target = EventUtil.getTarget(event);
 //取得提交按钮
 var btn = target.elements[&quot;submit-btn&quot;];
 //禁用它
 btn.disabled = true;
});
</code></pre><p>以上代码为表单的 submit 事件添加了一个事件处理程序。事件触发后，代码取得了提交按钮<br>并将其 disabled 属性设置为 true。注意，不能通过 onclick 事件处理程序来实现这个功能，原<br>因是不同浏览器之间存在“时差”：有的浏览器会在触发表单的 submit 事件之前触发 click 事件，<br>而有的浏览器则相反。对于先触发 click 事件的浏览器，意味着会在提交发生之前禁用按钮，结果<br>永远都不会提交表单。因此，最好是通过 submit 事件来禁用提交按钮。不过，这种方式不适合表<br>单中不包含提交按钮的情况；<strong>如前所述，只有在包含提交按钮的情况下，才有可能触发表单的 submit<br>事件。</strong></p>
<h4 id="4-文档加载时自动获得焦点"><a href="#4-文档加载时自动获得焦点" class="headerlink" title="(4)文档加载时自动获得焦点"></a>(4)文档加载时自动获得焦点</h4><pre><code>EventUtil.addHandler(window,&quot;load&quot;,function(event){

    document.forms[0].elements[0].focus();
}) 
</code></pre><h4 id="5-针对某个控件过滤所有按钮输入"><a href="#5-针对某个控件过滤所有按钮输入" class="headerlink" title="(5)针对某个控件过滤所有按钮输入"></a>(5)针对某个控件过滤所有按钮输入</h4><pre><code>EventUtil.addHandler(textbox, &quot;keypress&quot;, function(event){
 event = EventUtil.getEvent(event);
 EventUtil.preventDefault(event);
}); 
</code></pre><h4 id="6-针对某个控件只过滤特定字符"><a href="#6-针对某个控件只过滤特定字符" class="headerlink" title="(6)针对某个控件只过滤特定字符"></a>(6)针对某个控件只过滤特定字符</h4><p>如下只能输入数字   </p>
<pre><code>var textbox = document.getElementById(&quot;textboxs&quot;);
   EventUtil.addHandler(textbox, &quot;keypress&quot;, function (event) {
       event = EventUtil.getEvent(event);
       var target = EventUtil.getTarget(event);
       var charCode = EventUtil.getCharCode(event);
       if (!/\d/.test(String.fromCharCode(charCode))) {
           EventUtil.preventDefault(event);
       }
   }); 
</code></pre><h4 id="7-针对某一个控件输入完毕后自动切换焦点到下一个控件"><a href="#7-针对某一个控件输入完毕后自动切换焦点到下一个控件" class="headerlink" title="(7)针对某一个控件输入完毕后自动切换焦点到下一个控件"></a>(7)针对某一个控件输入完毕后自动切换焦点到下一个控件</h4><p>Html  </p>
<pre><code>&lt;input type=&quot;text&quot; name=&quot;tel1&quot; id=&quot;txtTel1&quot; maxlength=&quot;3&quot;&gt;
&lt;input type=&quot;text&quot; name=&quot;tel2&quot; id=&quot;txtTel2&quot; maxlength=&quot;3&quot;&gt;
&lt;input type=&quot;text&quot; name=&quot;tel3&quot; id=&quot;txtTel3&quot; maxlength=&quot;4&quot;&gt; 
</code></pre><p>JavaScript</p>
<pre><code>(function () {
    function tabForward(event) {
        event = EventUtil.getEvent(event);
        var target = EventUtil.getTarget(event);
        if (target.value.length == target.maxLength) {
            var form = target.form;
            for (var i = 0, len = form.elements.length; i &lt; len; i++) {
                if (form.elements[i] == target) {
                    if (form.elements[i + 1]) {
                        form.elements[i + 1].focus();
                    }
                    return;
                }
            }
        }
    }
    /*以上为处理焦点切换的函数*/
    var textbox1 = document.getElementById(&quot;txtTel1&quot;);
    var textbox2 = document.getElementById(&quot;txtTel2&quot;);
    var textbox3 = document.getElementById(&quot;txtTel3&quot;);
    //获取textbox
    EventUtil.addHandler(textbox1, &quot;keyup&quot;, tabForward);
    EventUtil.addHandler(textbox2, &quot;keyup&quot;, tabForward);
    EventUtil.addHandler(textbox3, &quot;keyup&quot;, tabForward);
    /*给textbox添加事件*/
})(); 
</code></pre><h4 id="8-h5一些属性"><a href="#8-h5一些属性" class="headerlink" title="(8)h5一些属性"></a>(8)h5一些属性</h4><blockquote>
<p>*第一种情况是在表单字段中指定了 required 属性，如下面的例子所示：  </p>
</blockquote>
<pre><code>&lt;input type=&quot;text&quot; name=&quot;username&quot; required&gt;
</code></pre><blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<pre><code>&lt;input type=&quot;email&quot; name =&quot;email&quot;&gt;

&lt;input type=&quot;url&quot; name=&quot;homepage&quot;&gt; 
</code></pre><h4 id="9-给选择框加选项"><a href="#9-给选择框加选项" class="headerlink" title="(9)给选择框加选项"></a>(9)给选择框加选项</h4><p>可以使用 JavaScript 动态创建选项，并将它们添加到选择框中。添加选项的方式有很多，第一种方<br>式就是使用如下所示的 DOM 方法。  </p>
<pre><code>var newOption = document.createElement(&quot;option&quot;);
newOption.appendChild(document.createTextNode(&quot;Option text&quot;));
newOption.setAttribute(&quot;value&quot;, &quot;Option value&quot;);
selectbox.appendChild(newOption); 
</code></pre><h4 id="10-小结"><a href="#10-小结" class="headerlink" title="(10)小结"></a>(10)小结</h4><pre><code>  虽然 HTML 和 Web 应用自诞生以来已经发生了天翻地覆的变化，但 Web 表单相对却没有什么改
变。使用 JavaScript 可以增强已有的表单字段，从而创造出新的功能，或者提升表单的易用性。为此，
表单、表单字段都引入了相应的属性和方法，以便 JavaScript 使用。下面是本章介绍的几个概念。
1 可以使用一些标准或非标准的方法选择文本框中的全部或部分文本。
2 大多数浏览器都采用了 Firefox 操作选择文本的方式，但 IE 仍然坚持自己的实现。

3 在文本框的内容变化时，可以通过侦听键盘事件以及检测插入的字符，来允许或禁止用户输入
某些字符。
除 Opera 之外的所有浏览器都支持剪贴板事件，包括 copy、cut 和 paste。其他浏览器在实现剪
贴板事件时也可以分为几种不同的情况。
4IE、Firefox、Chrome 和 Safari 允许通过 JavaScript 访问剪贴板中的数据，而 Opera 不允许这种访
问方式。
5 即使是 IE、Chrome 和 Safari，它们各自的实现方式也不相同。
6  Firefox、Safari 和 Chrome 只允许在 paste 事件发生时读取剪贴板数据，而 IE 没有这个限制。
7  Firefox、Safari 和 Chrome 只允许在发生剪贴板事件时访问与剪贴板相关的信息，而 IE 允许在任
何时候访问相关信息。
在文本框内容必须限制为某些特定字符的情况下，就可以利用剪贴板事件来屏蔽通过粘贴向文本框
中插入内容的操作。
8选择框也是经常要通过 JavaScript 来控制的一个表单字段。由于有了 DOM，对选择框的操作比以前
要方便多了。添加选项、移除选项、将选项从一个选择框移动到另一个选择框，甚至对选项进行排序等
操作，都可以使用标准的 DOM 技术来实现。
   富文本编辑功能是通过一个包含空 HTML 文档的 iframe 元素来实现的。通过将空文档的
designMode 属性设置为&quot;on&quot;，就可以将该页面转换为可编辑状态，此时其表现如同字处理软件。另外，
也可以将某个元素设置为 contenteditable。在默认情况下，可以将字体加粗或者将文本转换为斜体，
还可以使用剪贴板。JavaScript 通过使用 execCommand()方法也可以实现相同的一些功能。另外，使用
queryCommandEnabled()、queryCommandState()和 queryCommandValue()方法则可以取得有关
文本选区的信息。由于以这种方式构建的富文本编辑器并不是一个表单字段，因此在将其内容提交给
服务器之前，必须将 iframe 或 contenteditable 元素中的 HTML 复制到一个表单字段中。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/javascript高级程序设计/十三 demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/17/javascript高级程序设计/十三 demo/" itemprop="url">第十三章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T21:51:41+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/17/javascript高级程序设计/十三 demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/17/javascript高级程序设计/十三 demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-DOM2级事件处理程序"><a href="#1-DOM2级事件处理程序" class="headerlink" title="(1)DOM2级事件处理程序"></a>(1)DOM2级事件处理程序</h4><p>   “DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()<br>和 removeEventListener()。所有 DOM 节点中都包含这两个方法，并且它们都接受 3 个参数：要处<br>理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获<br>阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。<br>要在按钮上为 click 事件添加事件处理程序，可以使用下列代码：</p>
<pre><code>&lt;body&gt;

    &lt;button&gt;&lt;/button&gt;

    &lt;script&gt;
        var ben = document.getElementById(&quot;myBtn&quot;);
        ben.addEventListener(&quot;click&quot;, function () {

            alert(this.id);
        }, false);
      /*上面的代码为一个按钮添加了 onclick 事件处理程序，而且该事件会在冒泡阶段被触发（因为最
后一个参数是 false）。*/
    &lt;/script&gt;
</code></pre><p> 上面的代码为一个按钮添加了 onclick 事件处理程序，而且该事件会在冒泡阶段被触发（因为最<br>后一个参数是 false）。</p>
<h4 id="2-在不同浏览器中通过能力检测来加减方法处理程序，万金油"><a href="#2-在不同浏览器中通过能力检测来加减方法处理程序，万金油" class="headerlink" title="(2)在不同浏览器中通过能力检测来加减方法处理程序，万金油"></a>(2)在不同浏览器中通过能力检测来加减方法处理程序，万金油</h4><pre><code>&lt;html&gt;



&lt;body&gt;

&lt;button id=&quot;clickMe&quot;&gt;点我，点我，别害羞&lt;/button&gt;
&lt;script&gt;
    /*万金油式处理事件方法*/
    var EventUtil = {
        addHandler: function (element, type, handler) {
            if (element.addEventListener) {

                element.addEventListener(type, handler, false);
            } else if (element.attachEvent) {
                element.attachEvent(&quot;on&quot; + type, handler);
            } else {
                element[&quot;on&quot; + type] = handler;
            }
        },
        removeHandler: function (element, type, handler) {
            if (element.removeEventListener) {
                element.removeEventListener(type, handler, false);
            } else if (element.detachEvent) {
                element.detachEvent(&quot;on&quot; + type, handler);
            } else {
                element[&quot;on&quot; + type] = null;
            }

        }
    }

    /*如何使用呢？*/
    var clickme = document.getElementById(&quot;clickMe&quot;);
    var handler = function () {
        alert(&quot;Clicked&quot;);
    }

    EventUtil.addHandler(clickme, &quot;click&quot;, handler);/*添加事件*/
    EventUtil.removeHandler(clickme, &quot;click&quot;, handler);/*移除事件*/

&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><blockquote>
<p>  这两个方法首先都会检测传入的元素中是否存在 DOM2 级方法。如果存在 DOM2 级方法，则使用<br>该方法：传入事件类型、事件处理程序函数和第三个参数 false（表示冒泡阶段）。如果存在的是 IE 的<br>方法，则采取第二种方案。注意，为了在 IE8 及更早版本中运行，此时的事件类型必须加上”on”前缀。<br>最后一种可能就是使用 DOM0 级方法（在现代浏览器中，应该不会执行这里的代码）。此时，我们使用<br>的是方括号语法来将属性名指定为事件处理程序，或者将属性设置为 null。</p>
</blockquote>
<h4 id="3-在一个函数里面处理多个事件时，可以用type属性"><a href="#3-在一个函数里面处理多个事件时，可以用type属性" class="headerlink" title="(3)在一个函数里面处理多个事件时，可以用type属性"></a>(3)在一个函数里面处理多个事件时，可以用type属性</h4><pre><code>&lt;html&gt;
&lt;body&gt;
    &lt;button id=&quot;clickMe&quot;&gt;点我，点我，别害羞&lt;/button&gt;
    &lt;script&gt;
        var btn = document.getElementById(&quot;clickMe&quot;);
        var handler = function (event) {

            switch (event.type) {
                case &quot;click&quot;:
                    alert(&quot;clickMe,ye&quot;);
                    break;
                case &quot;mouseover&quot;:
                    event.target.style.backgroundColor = &quot;red&quot;;
                    break;
            }
        }

        btn.onclick = handler;
        btn.onmouseover = handler;
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><p>我们以此给了btn加了三个事件。只用了一个函数。</p>
<h4 id="4-跨浏览器的事件对象，以下代码可以再IE和其他浏览器运行，做好了能力检测。万金油"><a href="#4-跨浏览器的事件对象，以下代码可以再IE和其他浏览器运行，做好了能力检测。万金油" class="headerlink" title="(4)跨浏览器的事件对象，以下代码可以再IE和其他浏览器运行，做好了能力检测。万金油"></a>(4)跨浏览器的事件对象，以下代码可以再IE和其他浏览器运行，做好了能力检测。万金油</h4><pre><code>&lt;html&gt;

&lt;body&gt;
    &lt;button id=&quot;clickMe&quot;&gt;点我，点我，别害羞&lt;/button&gt;
    &lt;script&gt;
        var EventUtil = {
            addHandler: function (element, type, handler) {
                //省略的代码，上面有
            },
            getEvent: function (event) {
                return event ? event : window.event;
            },
            getTarget: function (event) {
                return event.target || event.srcElement;
            },

            preventDefault: function (event) {
                if (event.preventDefault) {
                    event.preventDefault();
                } else {
                    event.returnValue = false;
                }
            },

            removeHandler: function (element, type, handler) {
                //省略的代码，上面例子有
            },
            stopPropagation: function (event) {
                if (event.stopPropagation) {
                    event.stopPropagation();
                } else {
                    event.cancelBubble = true;
                }
            }
        };


    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><h4 id="4-事件类型"><a href="#4-事件类型" class="headerlink" title="(4)事件类型"></a>(4)事件类型</h4><p> 1  确定浏览器是否支持DOM2级事件可以用以下代码   </p>
<pre><code>var isSupported = document.implementation.hasFeature(&quot;HTMLEvents&quot;, &quot;2.0&quot;);  
</code></pre><p>注意，只有根据“DOM2 级事件”实现这些事件的浏览器才会返回 true。而以非标准方式支持这<br>些事件的浏览器则会返回 false。要确定浏览器是否支持“DOM3 级事件”定义的事件，可以使用如下<br>代码：  </p>
<pre><code>var isSupported = document.implementation.hasFeature(&quot;UIEvent&quot;, &quot;3.0&quot;); 
</code></pre><h4 id="5-load事件引起加载script文件"><a href="#5-load事件引起加载script文件" class="headerlink" title="(5)load事件引起加载script文件"></a>(5)load事件引起加载script文件</h4><pre><code>EventUtil.addHandler(window, &quot;load&quot;, function () {
    var script = document.createElement(&quot;script&quot;);
    EventUtil.addHandler(script, &quot;load&quot;, function (event) {
        alert(&quot;LoadedScript&quot;);
    });
    script.src = &quot;demo.js&quot;;
    document.body.appendChild(script);
})
</code></pre><p>以上可以给文档加载时加一个加载js文件的方法.666</p>
<h4 id="6-以下列举一些事件-没事看看"><a href="#6-以下列举一些事件-没事看看" class="headerlink" title="(6)以下列举一些事件,没事看看."></a>(6)以下列举一些事件,没事看看.</h4><blockquote>
<ul>
<li>当浏览器窗口被调整到一个新的高度或宽度时，就会触发 resize 事件。</li>
</ul>
</blockquote>
<pre><code> EventUtil.addHandler(window, &quot;resize&quot;, function(event){  
 alert(&quot;Resized&quot;);  
}); 
</code></pre><blockquote>
<ul>
<li>当焦点从页面中的一个元素移动到另一个元素，会依次触发下列事件：<br>(1) focusout 在失去焦点的元素上触发；<br>(2) focusin 在获得焦点的元素上触发；<br>(3) blur 在失去焦点的元素上触发；<br>(4) DOMFocusOut 在失去焦点的元素上触发；<br>(5) focus 在获得焦点的元素上触发；<br>(6) DOMFocusIn 在获得焦点的元素上触发。<br>其中，blur、DOMFocusOut 和 focusout 的事件目标是失去焦点的元素；而 focus、DOMFocusIn<br>和 focusin 的事件目标是获得焦点的元素。<br>要确定浏览器是否支持这些事件，可以使用如下代码：  </li>
</ul>
</blockquote>
<pre><code>var isSupported = document.implementation.hasFeature(&quot;FocusEvent&quot;, &quot;3.0&quot;); 
</code></pre><h4 id="7-可以通过获取鼠标点击的位置来显示鼠标点击的位置"><a href="#7-可以通过获取鼠标点击的位置来显示鼠标点击的位置" class="headerlink" title="(7)可以通过获取鼠标点击的位置来显示鼠标点击的位置."></a>(7)可以通过获取鼠标点击的位置来显示鼠标点击的位置.</h4><pre><code>&lt;html&gt;

&lt;body&gt;
  &lt;div  id=&quot;myDiv&quot;  style=&quot;width: 100%;height: 300px;&quot;&gt;&lt;/div&gt;

&lt;script&gt;
    var EventUtil = {
        addHandler: function (element, type, handler) {
            if (element.addEventListener) {
                element.addEventListener(type, handler, false);
            } else if (element.attachEvent) {
                element.attachEvent(&quot;on&quot; + type, handler);
            } else {
                element[&quot;on&quot; + type] = handler;
            }

        },
        getEvent: function (event) {
            return event ? event : window.event;
        },
        getTarget: function (event) {
            return event.target || event.srcElement;
        },

        preventDefault: function (event) {
            if (event.preventDefault) {
                event.preventDefault();
            } else {
                event.returnValue = false;
            }
        },

        removeHandler: function (element, type, handler) {
            if (element.removeEventListener) {
                element.removeEventListener(type, handler, false);
            } else if (element.detachEvent) {
                element.detachEvent(&quot;on&quot; + type, handler);
            } else {
                element[&quot;on&quot; + type] = null;
            }

        },
        stopPropagation: function (event) {
            if (event.stopPropagation) {
                event.stopPropagation();
            } else {
                event.cancelBubble = true;
            }
        }
    };



   var div=document.getElementById(&quot;myDiv&quot;);
   EventUtil.addHandler(div,&quot;click&quot;,function(event){
       event=EventUtil.getEvent(event);
       alert(&quot;Page coordinates:&quot;+event.pageX+&quot;,&quot;+event.pageY);
   })


&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><h4 id="8-检测用户是否同时按下了键盘键"><a href="#8-检测用户是否同时按下了键盘键" class="headerlink" title="(8)检测用户是否同时按下了键盘键"></a>(8)检测用户是否同时按下了键盘键</h4><pre><code>var div=document.getElementById(&quot;myDiv&quot;);
EventUtil.addHandler(div,&quot;click&quot;,function(event){
    event=EventUtil.getEvent(event);
   var keys=new Array();
   if(event.shiftKey){
             keys.push(&quot;shift&quot;);

   }
   if(event.ctrlKey){
             keys.push(&quot;ctrl&quot;);

   }
   if(event.altKey){
             keys.push(&quot;alt&quot;);

   }

alert(keys.join(&quot;,&quot;));

})
</code></pre><p>这里检测用户是否同时按下了shift，ctrl，alt</p>
<h4 id="9-键盘和文本事件"><a href="#9-键盘和文本事件" class="headerlink" title="(9)键盘和文本事件"></a>(9)键盘和文本事件</h4><pre><code>var textBox=document.getElementById(&quot;MyText&quot;);
EventUtil.addHandler(textBox,&quot;keyup&quot;,function(event){
    event=EventUtil.getEvent(event);
    alert(event.keyCode);
})
</code></pre><p>以上代码能帮助我们捕获到用户点击文本框的的键盘的键码进而显示。</p>
<h4 id="10-事件委托"><a href="#10-事件委托" class="headerlink" title="(10)事件委托"></a>(10)事件委托</h4><p>  对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事<br>件处理程序，就可以管理某一类型的所有事件。例如，click 事件会一直冒泡到 document 层次。<br>也就是说，我们可以为整个页面指定一个 onclick 事件处理程序，而不必给每个可单击的元素分别添加事<br>件处理程序。以下面的 HTML 代码为例。  </p>
<pre><code>HTML
 &lt;ul id=&quot;myLinks&quot;&gt;
        &lt;li id=&quot;goSomewhere&quot;&gt;Go somewhere&lt;/li&gt;
        &lt;li id=&quot;doSomething&quot;&gt;Do something&lt;/li&gt;
        &lt;li id=&quot;sayHi&quot;&gt;Say hi&lt;/li&gt;
       &lt;/ul&gt; 

    /*如果在一个复杂的 Web 应用程序中，对所有可单击的元素都采用这种方式，那么结果就会有数不
清的代码用于添加事件处理程序。此时，可以利用事件委托技术解决这个问题。使用事件委托，只需在
DOM 树中尽量最高的层次上添加一个事件处理程序，如下面的例子所示。*/
JAVASCRIPT  
   var list=document.getElementById(&quot;myLinks&quot;);
   EventUtil.addHandler(list,&quot;click&quot;,function(event){
    event=EventUtil.getEvent(event);
   var target=EventUtil.getTarget(event);
   switch(target.id){
      case &quot;doSomething&quot;:
          document.title=&quot;I changed the document&apos;s title&quot;;
          break;
      case &quot;goSomewhere&quot;:
      location.href= &quot;http://www.wrox.com&quot;; 
      break;
      case &quot;sayHi&quot;:
        alert(&quot;hi&quot;);
        break;
  }
   });
</code></pre><p><strong> 所有的按钮事件都可以用这种，取最高层次上的事件处理程序来处理。</strong></p>
<h4 id="11-模拟鼠标事件"><a href="#11-模拟鼠标事件" class="headerlink" title="(11)模拟鼠标事件"></a>(11)模拟鼠标事件</h4><p>html  </p>
<pre><code>&lt;button  id=&quot;myBtn&quot;&gt;nihoa&lt;/button&gt;
</code></pre><p>javascript  </p>
<pre><code> var btn = document.getElementById(&quot;myBtn&quot;);
//创建事件对象
var event = document.createEvent(&quot;MouseEvents&quot;);

btn.onclick=function(){
    alert(&quot;nihao&quot;);
}
//初始化事件对象
event.initMouseEvent(&quot;click&quot;, true, true, document.defaultView, 0, 0, 0, 0, 0,
 false, false, false, false, 0, null);

//触发事件
btn.dispatchEvent(event); 
</code></pre><h4 id="12-小结"><a href="#12-小结" class="headerlink" title="(12)小结"></a>(12)小结</h4><p>事件是将 JavaScript 与网页联系在一起的主要方式。“DOM3 级事件”规范和 HTML5 定义了常见的<br>大多数事件。即使有规范定义了基本事件，但很多浏览器仍然在规范之外实现了自己的专有事件，从而<br>为开发人员提供更多掌握用户交互的手段。有些专有事件与特定设备关联，例如移动 Safari 中的<br>orientationchange 事件就是特定关联 iOS 设备的。<br>在使用事件时，需要考虑如下一些内存与性能方面的问题。</p>
<blockquote>
<p><em>1 有必要限制一个页面中事件处理程序的数量，数量太多会导致占用大量内存，而且也会让用户<br>感觉页面反应不够灵敏。  
</em>2建立在事件冒泡机制之上的事件委托技术，可以有效地减少事件处理程序的数量。<br>*3建议在浏览器卸载页面之前移除页面中的所有事件处理程序。<br>可以使用 JavaScript 在浏览器中模拟事件。“DOM2 级事件”和“DOM3 级事件”规范规定了模拟事<br>件的方法，为模拟各种有定义的事件提供了方便。此外，通过组合使用一些技术，还可以在某种程度上<br>模拟键盘事件。IE8 及之前版本同样支持事件模拟，只不过模拟的过程有些差异。<br>事件是 JavaScript 中最重要的主题之一，深入理解事件的工作机制以及它们对性能的影响至关重要。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/javascript高级程序设计/十二 demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/17/javascript高级程序设计/十二 demo/" itemprop="url">第十二章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T21:46:56+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/17/javascript高级程序设计/十二 demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/17/javascript高级程序设计/十二 demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-本章因为个人原因先跳过了。有时间再看。"><a href="#1-本章因为个人原因先跳过了。有时间再看。" class="headerlink" title="(1)本章因为个人原因先跳过了。有时间再看。"></a>(1)本章因为个人原因先跳过了。有时间再看。</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/javascript高级程序设计/十一 demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/17/javascript高级程序设计/十一 demo/" itemprop="url">第十一章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T19:09:27+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/17/javascript高级程序设计/十一 demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/17/javascript高级程序设计/十一 demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-DOM扩展"><a href="#1-DOM扩展" class="headerlink" title="(1)DOM扩展"></a>(1)DOM扩展</h4><blockquote>
<p>这难道不就是jquery干的事情吗？？</p>
</blockquote>
<pre><code>querySelector()方法
querySelector()方法接收一个 CSS 选择符，返回与该模式匹配的第一个元素，如果没有找到匹
配的元素，返回 null。请看下面的例子。
&lt;html&gt;

&lt;body&gt;

    &lt;body&gt;

        &lt;div id=&quot;myDiv&quot;&gt;
               dlskajflk
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;script&gt;
      var body=document.querySelector(&quot;body&quot;);
      var myDiv=document.querySelector(&quot;#myDiv&quot;);
      alert(myDiv.outerHTML);//输出 &lt;div id=&quot;myDiv&quot;&gt; dlskajflk&lt;/div&gt;
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><h4 id="2-Html5定义了大量的JavaScript的API"><a href="#2-Html5定义了大量的JavaScript的API" class="headerlink" title="(2)Html5定义了大量的JavaScript的API"></a>(2)Html5定义了大量的JavaScript的API</h4><p>  1  比较有特点的是插入标记。可以直接设置一个便签的innerHTML直接插入一些便签。</p>
<pre><code>在读模式下，innerHTML 属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应
的 HTML 标记。在写模式下，innerHTML 会根据指定的值创建新的 DOM 树，然后用这个 DOM 树完全
替换调用元素原先的所有子节点。下面是一个例子。
&lt;div id=&quot;content&quot;&gt;
 &lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt;
 &lt;ul&gt;
 &lt;li&gt;Item 1&lt;/li&gt;
 &lt;li&gt;Item 2&lt;/li&gt;
 &lt;li&gt;Item 3&lt;/li&gt;
 &lt;/ul&gt;
&lt;/div&gt;
对于上面的&lt;div&gt;元素来说，它的 innerHTML 属性会返回如下字符串。
&lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;Item 1&lt;/li&gt;
 &lt;li&gt;Item 2&lt;/li&gt;
 &lt;li&gt;Item 3&lt;/li&gt;
&lt;/ul&gt; 
</code></pre><p>而设置也超级简单。</p>
<blockquote>
<p>  div.innerHTML = “Hello &amp; welcome, <b>\”reader\”!</b>“; </p>
</blockquote>
<h4 id="3-不要频繁使用innerHTML"><a href="#3-不要频繁使用innerHTML" class="headerlink" title="(3)不要频繁使用innerHTML"></a>(3)不要频繁使用innerHTML</h4><pre><code>&lt;html&gt;

&lt;body&gt;

    &lt;body&gt;

        &lt;div id=&quot;myDiv&quot;&gt;
               dlskajflk
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;script&gt;
      for(var i=0,len=values.length;i&lt;len;i++){

        ul.innerHTML+=&quot;&lt;li&gt;&quot;+values[i]+&quot;&lt;/li&gt;&quot;;
      }
   /*这个算法不好，这样会频繁的访问ul.innerHTML，性能很差*/
      var itemsHtml=&quot;&quot;;
      for(var i=0,len=values.length;i&lt;len;i++){
          itemsHtml+=&quot;&lt;li&gt;&quot;+values[i]+&quot;&lt;/li&gt;&quot;;
      }
      ul.innerHTML=itemsHtml;
      /*我们应该不断累加，再一次性加给innerHTML。*/
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><h4 id="4-contains-方法"><a href="#4-contains-方法" class="headerlink" title="(4)contains()方法"></a>(4)contains()方法</h4><p>   在实际开发中，经常需要知道某个节点是不是另一个节点的后代。IE 为此率先引入了 contains()<br>方法，以便不通过在 DOM 文档树中查找即可获得这个信息。调用 contains()方法的应该是祖先节点，<br>也就是搜索开始的节点，这个方法接收一个参数，即要检测的后代节点。如果被检测的节点是后代节点，<br>该方法返回 true；否则，返回 false。以下是一个例子：<br>alert(document.documentElement.contains(document.body)); //true<br>当然，考虑到不同浏览器之间的支持程度。我们可以使用一种通用的函数。比如。  </p>
<pre><code>function contains(refNode, otherNode) {
       if (typeof refNode.contains == &quot;function&quot; &amp;&amp;
           (!client.engine.webkit || client.engine.webkit &gt;= 522)) {
           return refNode.contains(otherNode);
       } else if (typeof refNode.compareDocumentPosition == &quot;function&quot;) {
           return !!(refNode.compareDocumentPosition(otherNode) &amp; 16);
       } else {
           var node = otherNode.parentNode;
           do {
               if (node === refNode) {
                   return true;
               } else {
                   node = node.parentNode;
               }
           } while (node !== null);

           return false;
       }
   } 

   alert(contains(document.getElementById(&quot;myDiv&quot;)),document.getElementById(&quot;myLi&quot;))
</code></pre><h4 id="5-innerText属性"><a href="#5-innerText属性" class="headerlink" title="(5)innerText属性"></a>(5)innerText属性</h4><p>通过 innertText 属性可以操作元素中包含的所有文本内容，包括子文档树中的文本。在通过<br>innerText 读取值时，它会按照由浅入深的顺序，将子文档树中的所有文本拼接起来。在通过<br>innerText 写入值时，<strong>结果会删除元素的所有子节点，插入包含相应文本值的文本节点。</strong>来看下面这<br>个 HTML 代码示例。  </p>
<pre><code>&lt;div id=&quot;content&quot;&gt;
 &lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt;
 &lt;ul&gt;
 &lt;li&gt;Item 1&lt;/li&gt;
 &lt;li&gt;Item 2&lt;/li&gt;
 &lt;li&gt;Item 3&lt;/li&gt;
 &lt;/ul&gt;
&lt;/div&gt;
InnerTextExample01.htm
对于这个例子中的&lt;div&gt;元素而言，其 innerText 属性会返回下列字符串：
This is a paragraph with a list following it.
Item 1
Item 2
Item 3 
</code></pre><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="(6)小结"></a>(6)小结</h4><blockquote>
<ul>
<li>虽然 DOM 为与 XML 及 HTML 文档交互制定了一系列核心 API，但仍然有几个规范对标准的 DOM<br>进行了扩展。这些扩展中有很多原来是浏览器专有的，但后来成为了事实标准，于是其他浏览器也都提<br>供了相同的实现。本章介绍的三个这方面的规范如下。</li>
<li>1 Selectors API，定义了两个方法，让开发人员能够基于 CSS 选择符从 DOM 中取得元素，这两个<br>方法是 querySelector()和 querySelectorAll()。</li>
<li>2 Element Traversal，为 DOM 元素定义了额外的属性，让开发人员能够更方便地从一个元素跳到<br>另一个元素。之所以会出现这个扩展，是因为浏览器处理 DOM 元素间空白符的方式不一样。</li>
<li>HTML5，为标准的 DOM 定义了很多扩展功能。其中包括在 innerHTML 属性这样的事实标准基<br>础上提供的标准定义，以及为管理焦点、设置字符集、滚动页面而规定的扩展 API。<br>虽然目前 DOM 扩展的数量还不多，但随着 Web 技术的发展，相信一定还会涌现出更多扩展来。很<br>多浏览器都在试验专有的扩展，而这些扩展一旦获得认可，就能成为“伪”标准，甚至会被收录到规范<br>的更新版本中。</li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/javascript高级程序设计/十 demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/17/javascript高级程序设计/十 demo/" itemprop="url">第十章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T13:54:51+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/17/javascript高级程序设计/十 demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/17/javascript高级程序设计/十 demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-DOM"><a href="#1-DOM" class="headerlink" title="(1)DOM"></a>(1)DOM</h4><p>这一章主要针对不同浏览器要使用功能时做出的检测是否支持这个功能的一章。<br>没啥意思。</p>
<h4 id="2-Document类型"><a href="#2-Document类型" class="headerlink" title="(2)Document类型"></a>(2)Document类型</h4><p>  JavaScript 通过 Document 类型表示文档。在浏览器中，document 对象是 HTMLDocument（继承<br>自 Document 类型）的一个实例，表示整个 HTML 页面。而且，document 对象是 window 对象的一个<br>属性，因此可以将其作为全局对象来访问。<br>通过它可以访问到文档各种信息。 </p>
<pre><code>//取得完整的 URL
 var url = document.URL;
 //取得域名
 var domain = document.domain;
 //取得来源页面的 URL
 var referrer = document.referrer; 
</code></pre><h4 id="3-文档写入"><a href="#3-文档写入" class="headerlink" title="(3)文档写入"></a>(3)文档写入</h4><p>如果想要documen.write来写入我们需要插入到界面的JavaScript代码可以这样。  </p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
document.write(&quot;&lt;script type=\&quot;text/javascript\&quot;   src=\&quot;file.js\&quot; &gt;&quot; +&quot;&lt;\/script&gt;&quot;); 
&lt;/script&gt; 
</code></pre><h4 id="4-node遍历"><a href="#4-node遍历" class="headerlink" title="(4)node遍历"></a>(4)node遍历</h4><blockquote>
<p>不过，如果想要遍历元素的特性，attributes 属性倒是可以派上用场。在需要将 DOM 结构序列<br>化为 XML 或 HTML 字符串时，多数都会涉及遍历元素特性。以下代码展示了如何迭代元素的每一个特<br>性，然后将它们构造成 name=”value” name=”value”这样的字符串格式<br>。  </p>
</blockquote>
<pre><code>function outputAttributes(element){
 var pairs = new Array(),
 attrName,
 attrValue,
 i,
 len;
 for (i=0, len=element.attributes.length; i &lt; len; i++){
 attrName = element.attributes[i].nodeName;
 attrValue = element.attributes[i].nodeValue;
 pairs.push(attrName + &quot;=\&quot;&quot; + attrValue + &quot;\&quot;&quot;);
 }
 return pairs.join(&quot; &quot;);
} 
</code></pre><h4 id="5-遍历元素子节点"><a href="#5-遍历元素子节点" class="headerlink" title="(5)遍历元素子节点"></a>(5)遍历元素子节点</h4><pre><code>&lt;html&gt;

&lt;body&gt;
    &lt;ul id=&quot;myList&quot;&gt;
        &lt;li&gt;jlk&lt;/li&gt;
        &lt;li&gt;jlksdjflk&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        var mylist = document.getElementById(&quot;myList&quot;);

        for (var i = 0, len = mylist.childNodes.length; i &lt; len; i++) {
            if (mylist.childNodes[i].nodeType == 1) {
                alert(mylist.childNodes[i].nodeName);//LI
            }
        }
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><h4 id="6-用js代码实现加载js和css文件"><a href="#6-用js代码实现加载js和css文件" class="headerlink" title="(6)用js代码实现加载js和css文件"></a>(6)用js代码实现加载js和css文件</h4><p>比如在同级目录下有一个demo.js文件，我们不想用标签引用，只想用代码引入。我们可以</p>
<pre><code>function loadScript(url){
       var script=document.createElement(&quot;script&quot;);
       script.type=&quot;text/javascript&quot;;
       script.src=url;
       document.body.appendChild(script);
   }
   loadScript(&quot;demo.js&quot;);

    /*需要注意的是，必须将&lt;link&gt;元素添加到&lt;head&gt;
    而不是&lt;body&gt;元素，才能保证在所有浏览器中的行为一致。整个过程可以用以下函数来表示：*/
    function loadStyles(url){
     var link = document.createElement(&quot;link&quot;);
     link.rel = &quot;stylesheet&quot;;
     link.type = &quot;text/css&quot;;
     link.href = url;
     var head = document.getElementsByTagName(&quot;head&quot;)[0];
     head.appendChild(link);
    }
    调用 loadStyles()函数的代码如下所示：
    loadStyles(&quot;styles.css&quot;); 
</code></pre><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="(7)小结"></a>(7)小结</h4><pre><code>  DOM 是语言中立的 API，用于访问和操作 HTML 和 XML 文档。DOM1 级将 HTML 和 XML 文档
形象地看作一个层次化的节点树，可以使用 JavaScript 来操作这个节点树，进而改变底层文档的外观和
结构。
  DOM 由各种节点构成，简要总结如下。
1 最基本的节点类型是 Node，用于抽象地表示文档中一个独立的部分；所有其他类型都继承自
Node。
2 Document 类型表示整个文档，是一组分层节点的根节点。在 JavaScript 中，document 对象是
Document 的一个实例。使用 document 对象，有很多种方式可以查询和取得节点。
3 Element 节点表示文档中的所有 HTML 或 XML 元素，可以用来操作这些元素的内容和特性。
4 另外还有一些节点类型，分别表示文本内容、注释、文档类型、CDATA 区域和文档片段。
访问 DOM 的操作在多数情况下都很直观，不过在处理&lt;script&gt;和&lt;style&gt;元素时还是存在一些
复杂性。由于这两个元素分别包含脚本和样式信息，因此浏览器通常会将它们与其他元素区别对待。这
些区别导致了在针对这些元素使用 innerHTML 时，以及在创建新元素时的一些问题。
理解 DOM 的关键，就是理解 DOM 对性能的影响。DOM 操作往往是 JavaScript 程序中开销最大的
部分，而因访问 NodeList 导致的问题为最多。NodeList 对象都是“动态的”，这就意味着每次访问
NodeList 对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少 DOM 操作。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/javascript高级程序设计/九 demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/17/javascript高级程序设计/九 demo/" itemprop="url">第九章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T13:47:11+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/17/javascript高级程序设计/九 demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/17/javascript高级程序设计/九 demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-客户端检测"><a href="#1-客户端检测" class="headerlink" title="(1)客户端检测"></a>(1)客户端检测</h4><p>这一章主要针对不同浏览器要使用功能时做出的检测是否支持这个功能的一章。<br>没啥意思。</p>
<h4 id="2-小结"><a href="#2-小结" class="headerlink" title="(2)小结"></a>(2)小结</h4><pre><code>   客户端检测是 JavaScript 开发中最具争议的一个话题。由于浏览器间存在差别，通常需要根据不同
浏览器的能力分别编写不同的代码。有不少客户端检测方法，但下列是最经常使用的。
1  能力检测：在编写代码之前先检测特定浏览器的能力。例如，脚本在调用某个函数之前，可能
要先检测该函数是否存在。这种检测方法将开发人员从考虑具体的浏览器类型和版本中解放出
来，让他们把注意力集中到相应的能力是否存在上。能力检测无法精确地检测特定的浏览器和
版本。

2    怪癖检测：怪癖实际上是浏览器实现中存在的 bug，例如早期的 WebKit 中就存在一个怪癖，即
它会在 for-in 循环中返回被隐藏的属性。怪癖检测通常涉及到运行一小段代码，然后确定浏
览器是否存在某个怪癖。由于怪癖检测与能力检测相比效率更低，因此应该只在某个怪癖会干
扰脚本运行的情况下使用。怪癖检测无法精确地检测特定的浏览器和版本。

3   用户代理检测：通过检测用户代理字符串来识别浏览器。用户代理字符串中包含大量与浏览器
有关的信息，包括浏览器、平台、操作系统及浏览器版本。用户代理字符串有过一段相当长的
发展历史，在此期间，浏览器提供商试图通过在用户代理字符串中添加一些欺骗性信息，欺骗
网站相信自己的浏览器是另外一种浏览器。用户代理检测需要特殊的技巧，特别是要注意 Opera
会隐瞒其用户代理字符串的情况。即便如此，通过用户代理字符串仍然能够检测出浏览器所用
的呈现引擎以及所在的平台，包括移动设备和游戏系统。
   在决定使用哪种客户端检测方法时，一般应优先考虑使用能力检测。怪癖检测是确定应该如何处理
代码的第二选择。而用户代理检测则是客户端检测的最后一种方案，因为这种方法对用户代理字符串具
有很强的依赖性。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/javascript高级程序设计/八 demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/17/javascript高级程序设计/八 demo/" itemprop="url">第八章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T11:49:20+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/17/javascript高级程序设计/八 demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/17/javascript高级程序设计/八 demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-window对象以及窗口框架"><a href="#1-window对象以及窗口框架" class="headerlink" title="(1) window对象以及窗口框架"></a>(1) window对象以及窗口框架</h4><blockquote>
<p>由于 window 对象同时扮演着 ECMAScript 中 Global 对象的角色，因此所有在全局作用域中声明<br>的变量、函数都会变成 window 对象的属性和方法。</p>
</blockquote>
<h4 id="2-窗口位置相对于top的位置"><a href="#2-窗口位置相对于top的位置" class="headerlink" title="(2) 窗口位置相对于top的位置"></a>(2) 窗口位置相对于top的位置</h4><pre><code>var leftPos=(typeof window.screenLeft==&apos;number&apos;)?
     window.screenLeft:window.screenX;
     alert(leftPos);
</code></pre><h4 id="3-检查弹出窗口是否被屏蔽了"><a href="#3-检查弹出窗口是否被屏蔽了" class="headerlink" title="(3)检查弹出窗口是否被屏蔽了"></a>(3)检查弹出窗口是否被屏蔽了</h4><p>如果浏览器扩展或者其他程序阻止弹出窗口的话。我们用try catch来判断</p>
<pre><code>var blocked = false;
try {
    var wrpxWin = window.open(&quot;http://www.wrox.com&quot;, &quot;_blank&quot;); if (wrpxWin == null) {
        blocked = true;//窗口被屏蔽了
    }
} catch (ex) {
    blocked = true;
}

if (blocked) {
    alert(&quot;the popupp was bolcked!&quot;);
}
</code></pre><h4 id="4-对话框"><a href="#4-对话框" class="headerlink" title="(4) 对话框"></a>(4) 对话框</h4><blockquote>
<ul>
<li>alert</li>
<li>confirm</li>
<li>prompt  </li>
</ul>
</blockquote>
<p>重点是第三种，让你输入一个对话框，并要求你输入数据。</p>
<pre><code> var result = prompt(&quot;what is you name?&quot;, &quot;&quot;);
 if (result != null) {
    alert(&quot;Welcome,&quot; + result);
}
</code></pre><h4 id="5-location对象"><a href="#5-location对象" class="headerlink" title="(5) location对象"></a>(5) location对象</h4><blockquote>
<p>location 是最有用的 BOM 对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一<br>些导航功能。事实上，location 对象是很特别的一个对象，因为它既是 window 对象的属性，也是<br>document 对象的属性；换句话说，window.location 和 document.location 引用的是同一个对象。<br>location 对象的用处不只表现在它保存着当前文档的信息，还表现在它将 URL 解析为独立的片段，让<br>开发人员可以通过不同的属性访问这些片段。</p>
</blockquote>
<h4 id="6-navigator对象-检测插件"><a href="#6-navigator对象-检测插件" class="headerlink" title="(6) navigator对象 检测插件"></a>(6) navigator对象 检测插件</h4><pre><code>function hasPlugin(name) {
    name = name.toLowerCase();
    for (var i = 0; i &lt; navigator.plugins.length; i++) {
        if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1) {
            return true;
        }
        return false;
    }
}
alert(hasPlugin(&quot;Flash&quot;));//检查是否有Flash插件
</code></pre><h4 id="6-history对象"><a href="#6-history对象" class="headerlink" title="(6) history对象"></a>(6) history对象</h4><blockquote>
<p>浏览器内置对象，可以用它模仿前一个界面，后一个界面操作。</p>
</blockquote>
<h4 id="7-小结"><a href="#7-小结" class="headerlink" title="(7) 小结"></a>(7) 小结</h4><pre><code>   浏览器对象模型（BOM）以 window 对象为依托，表示浏览器窗口以及页面可见区域。同时，window
对象还是 ECMAScript 中的 Global 对象，因而所有全局变量和函数都是它的属性，且所有原生的构造
函数及其他函数也都存在于它的命名空间下。本章讨论了下列 BOM 的组成部分。
1 在使用框架时，每个框架都有自己的 window 对象以及所有原生构造函数及其他函数的副本。
每个框架都保存在 frames 集合中，可以通过位置或通过名称来访问。
2 有一些窗口指针，可以用来引用其他框架，包括父框架。
3 top 对象始终指向最外围的框架，也就是整个浏览器窗口。
4 parent 对象表示包含当前框架的框架，而 self 对象则回指 window。
5 使用 location 对象可以通过编程方式来访问浏览器的导航系统。设置相应的属性，可以逐段
或整体性地修改浏览器的 URL。
6 调用 replace()方法可以导航到一个新 URL，同时该 URL 会替换浏览器历史记录中当前显示
的页面。
7 *navigator 对象提供了与浏览器有关的信息。到底提供哪些信息，很大程度上取决于用户的浏
览器；不过，也有一些公共的属性（如 userAgent）存在于所有浏览器中。
BOM 中还有两个对象：screen 和 history，但它们的功能有限。screen 对象中保存着与客户端
显示器有关的信息，这些信息一般只用于站点分析。history 对象为访问浏览器的历史记录开了一个
小缝隙，开发人员可以据此判断历史记录的数量，也可以在历史记录中向后或向前导航到任意页面。*
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/javascript高级程序设计/七 demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/17/javascript高级程序设计/七 demo/" itemprop="url">第七章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T11:24:14+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/17/javascript高级程序设计/七 demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/17/javascript高级程序设计/七 demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-访问器属性"><a href="#1-访问器属性" class="headerlink" title="(1) 访问器属性"></a>(1) 访问器属性</h4><pre><code>    var book={};
Object.defineProperties(book,{
   _year:{
       writable:true,
       value:2014
   }
})

/*以上的Object.defineProperties可以给book对象的加属性以及以及对属性的操作等*/
//当然，也可以读取属性的特性。
var descriptor=Object.getOwnPropertyDescriptor(book,&quot;_year&quot;);
alert(descriptor.value);  //2014
alert(descriptor.configurable);  //false
</code></pre><h4 id="2-在对象和原型中查找属性或者方法的顺序。"><a href="#2-在对象和原型中查找属性或者方法的顺序。" class="headerlink" title="(2) 在对象和原型中查找属性或者方法的顺序。"></a>(2) 在对象和原型中查找属性或者方法的顺序。</h4><blockquote>
<p>如果按照字面意思来理解，那<br>么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以<br>让所有对象实例共享它所包含的属性和方法。</p>
</blockquote>
<blockquote>
<p>.hasOwnProperty方法可以用来检查某个属性在实例中还是原型中。</p>
</blockquote>
<p>同时使用 hasOwnProperty()方法和 in 操作符，就可以确定该属性到底是存在于对象中，还是存在于<br>原型中，如下所示。  </p>
<pre><code> //这个函数实现认识某个属性在不在原型中，在的话，返回ture，否则返回false；
function hasPrototypeProperty(object, name) {
    return !object.hasOwnProperty(name) &amp;&amp; (name in object);
}
function Person() {
}
Person.prototype.name = &quot;nihao&quot;;
var person = new Person();
alert(hasPrototypeProperty(person, &quot;name&quot;));  //ture,表明name在原型中。
person.name = &quot;goobye&quot;;
alert(hasPrototypeProperty(person, &quot;name&quot;));  //false，不在原型中
</code></pre><h4 id="3-组合使用构造函数和原型模式"><a href="#3-组合使用构造函数和原型模式" class="headerlink" title="(3)组合使用构造函数和原型模式"></a>(3)组合使用构造函数和原型模式</h4><blockquote>
<p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实<br>例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，<br>但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参<br>数；可谓是集两种模式之长。下面的代码重写了前面的例子。  </p>
</blockquote>
<pre><code>/*构造函数用于实例化属性*/
    function Person(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.friends = [&apos;nihao&apos;, &quot;goobye&quot;];
    }


    /*原型模式用于定义方法和共享的属性*/
    Person.prototype = {
        constructor: Person,
        sayName: function () {

            alert(this.name);
        }
    }

    var person1 = new Person(&quot;nihao&quot;, 29, &quot;software Engineer&quot;)

    alert(person1.name);//nihao
</code></pre><h4 id="4-原型链"><a href="#4-原型链" class="headerlink" title="(4) 原型链"></a>(4) 原型链</h4><blockquote>
<ul>
<li>子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎<br>样，给原型添加方法的代码一定要放在替换原型的语句之后。</li>
</ul>
</blockquote>
<pre><code>function SuperType() {

      this.property = true;
  }
  SuperType.prototype.getSuperValue = function () {
      return this.property;
  }

  function SubType() {

      this.subproperty = false;
  }


  //继承实现
  SubType.prototype = new SuperType();
  //添加新方法
  SubType.prototype.getSubValue = function () {
      return his.subproperty;
  }
  //重写超类型方法
  SubType.prototype.getSuperValue = function () {

      return false;
  }
  var instanc = new SubType();
  alert(instanc.getSuperValue());  //false
</code></pre><h4 id="5-原型继承的问题以及解决"><a href="#5-原型继承的问题以及解决" class="headerlink" title="(5) 原型继承的问题以及解决"></a>(5) 原型继承的问题以及解决</h4><blockquote>
<p>它的问题就是当一个子类继承父类的时候，当定义子类对象时。子类某一个对象对父类中属性或者方法的改动都会反映到子类的其他对象中，<br>因为父类成了子类定义对象的原型。其他对象使用后也会有相应改变。那么可以使用借用构造函数来解决。  </p>
</blockquote>
<p>借用构造函数    </p>
<pre><code>function SuperType() {
     this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
 }
 function SubType() {
     //继承了Suptype
     SuperType.call(this);
 }

 var instance1 = new SubType();
 instance1.colors.push(&quot;black&quot;);//&quot;red,blue,green,black&quot; 
 alert(instance1.colors);
 var instance2 = new SubType();
 alert(instance2.colors);  //&quot;red,blue,green&quot; ,现在每个子类对象就保持了自己对父类的最初属性了。
</code></pre><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="(6) 小结"></a>(6) 小结</h4><blockquote>
<pre><code> ECMAScript 支持面向对象（OO）编程，但不使用类或者接口。对象可以在代码执行过程中创建和
 增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。
 1   工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来
 被构造函数模式所取代。
 2   构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用 new 操作符。不
 过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局
限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。
 3   原型模式，使用构造函数的 prototype 属性来指定那些应该共享的属性和方法。组合使用构造
 函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。
  JavaScript 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函
 数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。
 原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借
 用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的
 属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用
 原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。
 此外，还存在下列可供选择的继承模式。
 4   原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅
 复制。而复制得到的副本还可以得到进一步改造。
 5 寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强
 对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问
 题，可以将这个模式与组合继承一起使用。
 6  寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。
</code></pre></blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/javascript高级程序设计/六 demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/17/javascript高级程序设计/六 demo/" itemprop="url">第六章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T09:30:47+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/17/javascript高级程序设计/六 demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/17/javascript高级程序设计/六 demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-访问器属性"><a href="#1-访问器属性" class="headerlink" title="(1) 访问器属性"></a>(1) 访问器属性</h4><pre><code>    var book={};
Object.defineProperties(book,{
   _year:{
       writable:true,
       value:2014
   }
})

/*以上的Object.defineProperties可以给book对象的加属性以及以及对属性的操作等*/
//当然，也可以读取属性的特性。
var descriptor=Object.getOwnPropertyDescriptor(book,&quot;_year&quot;);
alert(descriptor.value);  //2014
alert(descriptor.configurable);  //false
</code></pre><h4 id="2-在对象和原型中查找属性或者方法的顺序。"><a href="#2-在对象和原型中查找属性或者方法的顺序。" class="headerlink" title="(2) 在对象和原型中查找属性或者方法的顺序。"></a>(2) 在对象和原型中查找属性或者方法的顺序。</h4><blockquote>
<p>如果按照字面意思来理解，那<br>么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以<br>让所有对象实例共享它所包含的属性和方法。</p>
</blockquote>
<blockquote>
<p>.hasOwnProperty方法可以用来检查某个属性在实例中还是原型中。</p>
</blockquote>
<p>同时使用 hasOwnProperty()方法和 in 操作符，就可以确定该属性到底是存在于对象中，还是存在于<br>原型中，如下所示。  </p>
<pre><code> //这个函数实现认识某个属性在不在原型中，在的话，返回ture，否则返回false；
function hasPrototypeProperty(object, name) {
    return !object.hasOwnProperty(name) &amp;&amp; (name in object);
}
function Person() {
}
Person.prototype.name = &quot;nihao&quot;;
var person = new Person();
alert(hasPrototypeProperty(person, &quot;name&quot;));  //ture,表明name在原型中。
person.name = &quot;goobye&quot;;
alert(hasPrototypeProperty(person, &quot;name&quot;));  //false，不在原型中
</code></pre><h4 id="3-组合使用构造函数和原型模式"><a href="#3-组合使用构造函数和原型模式" class="headerlink" title="(3)组合使用构造函数和原型模式"></a>(3)组合使用构造函数和原型模式</h4><blockquote>
<p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实<br>例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，<br>但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参<br>数；可谓是集两种模式之长。下面的代码重写了前面的例子。  </p>
</blockquote>
<pre><code>/*构造函数用于实例化属性*/
    function Person(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.friends = [&apos;nihao&apos;, &quot;goobye&quot;];
    }


    /*原型模式用于定义方法和共享的属性*/
    Person.prototype = {
        constructor: Person,
        sayName: function () {

            alert(this.name);
        }
    }

    var person1 = new Person(&quot;nihao&quot;, 29, &quot;software Engineer&quot;)

    alert(person1.name);//nihao
</code></pre><h4 id="4-原型链"><a href="#4-原型链" class="headerlink" title="(4) 原型链"></a>(4) 原型链</h4><blockquote>
<ul>
<li>子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎<br>样，给原型添加方法的代码一定要放在替换原型的语句之后。</li>
</ul>
</blockquote>
<pre><code>function SuperType() {

      this.property = true;
  }
  SuperType.prototype.getSuperValue = function () {
      return this.property;
  }

  function SubType() {

      this.subproperty = false;
  }


  //继承实现
  SubType.prototype = new SuperType();
  //添加新方法
  SubType.prototype.getSubValue = function () {
      return his.subproperty;
  }
  //重写超类型方法
  SubType.prototype.getSuperValue = function () {

      return false;
  }
  var instanc = new SubType();
  alert(instanc.getSuperValue());  //false
</code></pre><h4 id="5-原型继承的问题以及解决"><a href="#5-原型继承的问题以及解决" class="headerlink" title="(5) 原型继承的问题以及解决"></a>(5) 原型继承的问题以及解决</h4><blockquote>
<p>它的问题就是当一个子类继承父类的时候，当定义子类对象时。子类某一个对象对父类中属性或者方法的改动都会反映到子类的其他对象中，<br>因为父类成了子类定义对象的原型。其他对象使用后也会有相应改变。那么可以使用借用构造函数来解决。  </p>
</blockquote>
<p>借用构造函数    </p>
<pre><code>function SuperType() {
     this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
 }
 function SubType() {
     //继承了Suptype
     SuperType.call(this);
 }

 var instance1 = new SubType();
 instance1.colors.push(&quot;black&quot;);//&quot;red,blue,green,black&quot; 
 alert(instance1.colors);
 var instance2 = new SubType();
 alert(instance2.colors);  //&quot;red,blue,green&quot; ,现在每个子类对象就保持了自己对父类的最初属性了。
</code></pre><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="(6) 小结"></a>(6) 小结</h4><blockquote>
<pre><code> ECMAScript 支持面向对象（OO）编程，但不使用类或者接口。对象可以在代码执行过程中创建和
 增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。
 1   工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来
 被构造函数模式所取代。
 2   构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用 new 操作符。不
 过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局
限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。
 3   原型模式，使用构造函数的 prototype 属性来指定那些应该共享的属性和方法。组合使用构造
 函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。
  JavaScript 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函
 数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。
 原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借
 用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的
 属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用
 原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。
 此外，还存在下列可供选择的继承模式。
 4   原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅
 复制。而复制得到的副本还可以得到进一步改造。
 5 寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强
 对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问
 题，可以将这个模式与组合继承一起使用。
 6  寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。
</code></pre></blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/16/javascript高级程序设计/五  demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲍志强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="baobaobao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/16/javascript高级程序设计/五  demo/" itemprop="url">第五章笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-16T16:37:06+08:00">
                2018-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript高级程序设计读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript高级程序设计读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/16/javascript高级程序设计/五  demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/16/javascript高级程序设计/五  demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-引用类型"><a href="#1-引用类型" class="headerlink" title="(1) 引用类型"></a>(1) 引用类型</h4><p>  在 ECMAScript 中，引用类型是一种数据结构。<br>用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管 ECMAScript<br>从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基<br>本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。</p>
<h4 id="2-object定义"><a href="#2-object定义" class="headerlink" title="(2) object定义"></a>(2) object定义</h4><p>推荐定义object用字面量定义    </p>
<pre><code>var person = {    
 name : &quot;Nicholas&quot;,  
 age : 29  
};   
var person = {}; //与 new Object()相同  
person.name = &quot;Nicholas&quot;;  
person.age = 29;   
</code></pre><h4 id="3-array定义推荐"><a href="#3-array定义推荐" class="headerlink" title="(3)array定义推荐"></a>(3)array定义推荐</h4><pre><code>var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含 3 个字符串的数组  
var names = []; // 创建一个空数组 ,用它即可。 
var values = [1,2,]; // 不要这样！这样会创建一个包含 2 或 3 项的数组  
var options = [,,,,,]; // 不要这样！这样会创建一个包含 5 或 6 项的数组 
</code></pre><p>一些知识点</p>
<pre><code>/*1 动态给数组加数据，类似于线性表了。*/
var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含 3 个字符串的数组  
colors[colors.length] = &quot;black&quot;; //（在位置 3）添加一种颜色  
colors[colors.length] = &quot;brown&quot;; //（在位置 4）再添加一种颜色
/*2 数组的toLocaleString（）方法，其实是调用每一项的toString方法，输出。*/    
/*数组的栈以及队列方法  
push，pop，shift    
其中push和shift结合可以实现队列方法。*/ 
 var colors=new Array();    
     var count=colors.push(&quot;red&quot;,&quot;green&quot;);  //这个函数调用会返回2，有意思  
       alert(count);  
       count=colors.push(&quot;black&quot;);  
       alert(count);  
       var item=colors.shift();  //取得第一项,厉害了  
       alert(item);
</code></pre><h4 id="4-数组的迭代方法"><a href="#4-数组的迭代方法" class="headerlink" title="(4) 数组的迭代方法"></a>(4) 数组的迭代方法</h4><blockquote>
<ul>
<li>every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。</li>
<li>filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</li>
<li>forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。</li>
<li>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li>some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。<br>以上方法都不会修改数组中的包含的值。<br>在这些方法中，最相似的是 every()和 some()，它们都用于查询数组中的项是否满足某个条件。<br>对 every()来说，传入的函数必须对每一项都返回 true，这个方法才返回 true；否则，它就返回<br>false。而 some()方法则是只要传入的函数对数组中的某一项返回 true，就会返回 true。请看以下<br>例子。</li>
</ul>
</blockquote>
<pre><code>var numbers = [1, 2, 4, 343, 43, 423, 4];    
       var everyResult = numbers.every(function (item, index, array) {  
        return (item&gt;2)
       })
   alert(everyResult);  //false,他要求所有item都&gt;2才可以。
   var evetyResultq=numbers.some(function(item,index,array){  
   return  (item&gt;2)
   })
   alert(everyResult);//ture，他只要求其中有一个到几个&gt;2即可。
var filteResult=numbers.filter(function(item,index,array){
       return (item&gt;2);
   })
   alert(filteResult)  //返回这个数组所有大于2的数，并组成一个数组，这个牛逼了
</code></pre><h4 id="5-作为值的函数"><a href="#5-作为值的函数" class="headerlink" title="(5) 作为值的函数"></a>(5) 作为值的函数</h4><pre><code>/*因为 ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以  
像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。来看  
一看下面的函数。*/
  function callSomeFunction(someFunction, someArgument) {  
        return someFunction(someArgument);  //函数返回一个值，这个值就是一个函数
    }
    function add10num(num) {
        return num + 10;
    }
    var result = callSomeFunction(add10num, 10);
    alert(result);//20
</code></pre><h4 id="6-作为值的函数以及call"><a href="#6-作为值的函数以及call" class="headerlink" title="(6) 作为值的函数以及call"></a>(6) 作为值的函数以及call</h4><pre><code>  function callSomeFunction(someFunction, someArgument) {
      return someFunction(someArgument);  //函数返回一个值，这个值就是一个函数
  }
  function add10num(num) {
      return num + 10;
  }
  var result = callSomeFunction(add10num, 10);
  alert(result);//20
window.color = &quot;red&quot;;
  var o = { color: &quot;blue&quot; };
  function sayColor() {
      alert(this.color);
  }
  sayColor();
  sayColor.call(this);//red,这是全局变量使用
  sayColor.call(o);//blue，call可以帮我们指定this对象所指向的位置。完美
</code></pre><h4 id="7-基本包装类型的生存期以及后台解析成对象"><a href="#7-基本包装类型的生存期以及后台解析成对象" class="headerlink" title="(7)基本包装类型的生存期以及后台解析成对象"></a>(7)基本包装类型的生存期以及后台解析成对象</h4><pre><code>var s1=&quot;some text&quot;;
var s2=s1.substring(2);
/*后台其实是执行了这样的一个过程

(1) 创建 String 类型的一个实例；
(2) 在实例上调用指定的方法；
(3) 销毁这个实例。
可以将以上三个步骤想象成是执行了下列 ECMAScript 代码。
var s1 = new String(&quot;some text&quot;);
var s2 = s1.substring(2);
s1 = null;
经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于 Boolean
和 Number 类型对应的布尔值和数字值。
引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例，
在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一
行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。如下代码所示
 */

var s1 = &quot;some text&quot;;
s1.color = &quot;red&quot;;
alert(s1.color); //undefined
</code></pre><h4 id="（8）单体内置对象Global对象"><a href="#（8）单体内置对象Global对象" class="headerlink" title="（8）单体内置对象Global对象"></a>（8）单体内置对象Global对象</h4><blockquote>
<p>不属于任何其他对象的属性和方法，最终都是Global对象中的属性和方法。<br>winow对象,  </p>
</blockquote>
<p>  ECMAScript 虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是将这个全局对象作为<br>window 对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了 window<br>对象的属性。来看下面的例子。  </p>
<pre><code>var color = &quot;red&quot;;
function sayColor(){
 alert(window.color);
}
window.sayColor(); //&quot;red&quot; 
</code></pre><h4 id="（9）小结"><a href="#（9）小结" class="headerlink" title="（9）小结"></a>（9）小结</h4><pre><code>对象在 JavaScript 中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象，
现简要总结如下：
1 引用类型与传统面向对象程序设计中的类相似，但实现不同；
2 Object 是一个基础类型，其他所有类型都从 Object 继承了基本的行为；
3 Array 类型是一组值的有序列表，同时还提供了操作和转换这些值的功能；
4  Date 类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能；
5 RegExp 类型是 ECMAScript 支持正则表达式的一个接口，提供了最基本的和一些高级的正则表
达式功能。
函数实际上是 Function 类型的实例，因此函数也是对象；而这一点正是 JavaScript 最有特色的地
方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。
因为有了基本包装类型，所以 JavaScript 中的基本类型值可以被当作对象来访问。三种基本包装类
型分别是：Boolean、Number 和 String。以下是它们共同的特征：
6 每个包装类型都映射到同名的基本类型；
7 在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据
操作；
8 操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。
在所有代码执行之前，作用域中就已经存在两个内置对象：Global 和 Math。在大多数 ECMAScript
实现中都不能直接访问 Global 对象；不过，Web 浏览器实现了承担该角色的 window 对象。全局变
量和函数都是 Global 对象的属性。Math 对象提供了很多属性和方法，用于辅助完成复杂的数学计算
任务。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar1.jpg"
                alt="鲍志强" />
            
              <p class="site-author-name" itemprop="name">鲍志强</p>
              <p class="site-description motion-element" itemprop="description">求道者</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">70</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/baobaobaobaobao" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="530420396@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/bao-zhi-qiang-2/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">baobaobao</span>

  
</div>






  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  







  
  





  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_sphere.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://baobaobao.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
